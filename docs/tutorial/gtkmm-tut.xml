<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
  <!ENTITY url_refdocs_base_glib "../../reference/html/classGlib_1_1">
  <!ENTITY url_refdocs_base_gtk "../../reference/html/classGtk_1_1">
  <!ENTITY url_refdocs_base_gtk_namespace "../../reference/html/namespaceGtk_1_1">
  <!ENTITY url_figures_base "../figures/"> 
  <!ENTITY path_examples_base "../../examples/book/">
  <!ENTITY url_examples_base "../&path_examples_base;">
]>

<book xmlns:xi="http://www.w3.org/2001/XInclude">

<bookinfo>d

<title>Programming with gtkmm</title>

    <authorgroup>
      <author>
	<firstname>Murray</firstname>
	<surname>Cumming</surname>
      </author>
      <author>
	<firstname>Bernhard</firstname>
	<surname>Rieder</surname>
	<contrib>Chapter on &quot;Timeouts&quot;.</contrib>
      </author>
      <author>
	<firstname>Jason</firstname>
	<surname>M'Sadoques</surname>
	<contrib>Chapter on &quot;Drawing Area&quot;.</contrib>
      </author>
      <author>
	<firstname>Ole</firstname>
	<surname>Laursen</surname>
	<contrib>Parts of chapter on &quot;Internationalization&quot;.</contrib>
      </author>
	  <author>
	<firstname>Gene</firstname>
	<surname>Ruebsamen</surname>
	<contrib>Chapter on &quot;Win32 Installation&quot;.</contrib>
      </author>
	  	  <author>
	<firstname>Cedric</firstname>
	<surname>Gustin</surname>
	<contrib>Chapter on &quot;Win32 Installation&quot;.</contrib>
      </author>
   </authorgroup>

<abstract>

<para>Not all sections have
been completed - some have not been started.  Some chapters have been
written, but not edited or proofread.  Since they do contain helpful
information, they have been included, and are marked &quot;draft&quot;.
We are working hard to make this helpful and accurate.  We would very much appreciate any reports of
inaccuracies or other errors in this document.  Contributions are also
most welcome.  Post your suggestions, critiques or addenda to the <ulink
url="mailto:gtkmm-list@gnome.org">gtkmm mailing list</ulink>
-- The gtkmm Development Team
</para>

</abstract>

<copyright>
<year>2002</year>
<holder>Murray Cumming</holder>
</copyright>

<legalnotice>
<para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.2
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
      You may obtain a copy of the GNU Free Documentation License from the Free Software Foundation by visiting their Web site or by writing to: Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
</para>
</legalnotice>

</bookinfo>



<chapter id="sec-introduction">
<title>Introduction</title>

<sect1>
<title>This book</title>

<para>This book assumes a good
understanding of C++, and how to create C++ programs.
</para>

<para>This book attempts to explain key <literal>gtkmm</literal> concepts and introduce some of the more commonly used user interface elements ("widgets"). Although it mentions classes, constructors, and methods, it does not go into great detail. For full API information you should follow the links into the reference documentation.</para>

<para>
This document is a work in progress. You can find updates on the
<ulink url="http://www.gtkmm.org/">gtkmm home page</ulink>.
</para>

<para>
We would very much like to hear of any problems you have learning gtkmm
with this document, and would appreciate input regarding improvements. Please see the <link linkend="sec-Contributing">Contributing</link> section for further information.
</para>
</sect1>

<sect1 id="sec-gtkmm">
<title>gtkmm</title>
<para>
gtkmm is a C++ wrapper for 
<ulink url="http://www.gtk.org/">GTK+</ulink>, 
a library used to create graphical user
interfaces. It is licensed using the LGPL license, so you can develop
open software, free software, or even commercial non-free software
using gtkmm without purchasing licenses.
</para>
<para>gtkmm was originally named gtk-- because GTK+ already has a + in the name. However, as -- is not easily indexed by search engines the package generally went by the name gtkmm, and that's what we stuck with.</para>

<sect2>
<title>Why use gtkmm instead of GTK+?</title>
<para>gtkmm allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a C++ programmer you probably already realise that this leads to clearer and better organised code.</para>
<para>gtkmm is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration.</para>
<para>Inheritance can be used to derive new widgets. The derivation of new widgets in GTK+ C code is so complicated and error prone that almost no C coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique.</para>
<para>Member instances can be used, simplifying memory management. All GTK+ C widgets are dealt with by use of pointers. As a C++ coder you know that pointers should be avoided where possible.</para>
<para>gtkmm involves less code compared to GTK+, which uses prefixed function names and lots of cast macros.</para>
</sect2>

<sect2>
<title>gtkmm compared to QT</title>
<para>Trolltech's QT is the closest competition to gtkmm, so it deserves discussion.</para>

<para>gtkmm developers tend to prefer gtkmm to QT because gtkmm does things in a more C++ way. QT originates from a time when C++ and the standard library were not standardised or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the C++ language to provide signals, so that QT classes can not be used easily with non-QT classes. gtkmm was able to use standard C++ to provide signals without changing the C++ language. See the FAQ for more detailed differences.</para>
</sect2>

<sect2>
<title>gtkmm is a wrapper</title>
<para>
gtkmm is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation has advantages. The gtkmm developers spend most of their time talking about how gtkmm can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK+ code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users.</para>
<para>Microsoft's MFC has given GUI wrapper libraries a bad name, but gtkmm doesn't suffer from the same problems because GTK+ is written in high quality object-orientated C, with language-bindings in mind.</para>
</sect2>
</sect1>

</chapter>

<chapter id="sec-installation">
<title>Installation</title>
<para>
gtkmm can be downloaded from <ulink url="http://www.gtkmm.org/"></ulink>. 
</para>
<para>
Remember that you will probably need to be <literal>root</literal> to install software. The <literal>su</literal> command will allow you to enter the <literal>root</literal> password and have <literal>root</literal> status temporarily.</para>
<sect1>
<title>Dependencies</title>
<para>
Before installing gtkmm 2.4, you should first install these other packages.
</para>
<itemizedlist>
<listitem><para>libsigc++ 2.0</para></listitem>
<listitem><para>GTK+ 2.4</para></listitem>
</itemizedlist>
<para>
And GTK+ also requires these packages.
</para>
<itemizedlist>
<listitem><para>pkg-config</para></listitem>
<listitem><para>glib</para></listitem>
<listitem><para>ATK</para></listitem>
<listitem><para>Pango</para></listitem>
</itemizedlist>
</sect1>

<sect1 id="sec-install_unix_and_linux">
<title>Unix and Linux</title>

<sect2 id="sec-install_from_source">
<title>From Source</title>

<para>
gtkmm and its dependencies can be built and installed with the following sequence of commands:
<programlisting>
# ./configure
# make
# make install
</programlisting>
</para>
<para>
On some systems you will need to install to a different location. For instance, on Red Hat Linux systems you might use the <literal>--prefix</literal> option with configure, like so:
<programlisting>
# ./configure --prefix=/usr
</programlisting>
</para>
<para>
The configure script will warn you if you have not installed any of the other packages that it needs.
</para>
</sect2>

<sect2>
<title>Prebuilt Packages</title>

<sect3>
<title>Debian GNU/Linux</title>
<para>On Debian GNU/Linux, gtkmm 2.4 is available in unstable/sid. You can install gtkmm by typing this on the command-line:
<programlisting>
apt-get install libgtkmm2.4-dev
</programlisting>

If you use stable/woody however, you'll have to compile gtkmm yourself.
</para>
</sect3>

<sect3>
<title>Red Hat Linux</title>
<para>RedHat do not yet provide RPMs of gtkmm. We hope they will do this soon.</para>
</sect3>

<sect3>
<title>Mandrake Linux</title>
<para>TODO. gtkmm is in the betas.</para>
</sect3>
</sect2>
</sect1>

<sect1 id="sec-packages_windows">
<title>Microsoft Windows</title>
<para>GTK+ and gtkmm were designed to work well with Microsoft Windows, and the developers encourage its use on the win32 platform.  However, Windows has no standard installation system for development libraries. Please see the <link linkend="sec-windows-installation">Windows Installation</link>
appendix for win32-specific installation instructions and notes.</para>
</sect1>

</chapter>

<chapter id="sec-basics">
<title>Basics</title>

<para>
This chapter will introduce some of the most important aspects of gtkmm coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information.
</para>
<para>
Your existing knowledge of C++ will help you with gtkmm as it would with any library. Unless we state otherwise, you can expect gtkmm classes to behave like any other C++ class, and you can expect to use your existing C++ techniques with gtkmm classes.
</para>

<sect1>
<title>Simple Example</title>

<para>
To begin our introduction to gtkmm, we'll start with the simplest
program possible. This program will create an empty 200 x 200 pixel window.
</para>

<para>
Source location: examples/base/base.cc

<programlisting>
<xi:include href="../../examples/base/base.cc" parse="text"/>
</programlisting>


</para>

<para>We will now explain each line of the example</para>
<para>
<programlisting>
#include &lt;gtkmm.h&gt;
</programlisting>
</para>
<para>
All gtkmm programs must include certain gtkmm headers; <literal>gtkmm.h</literal>
includes the entire gtkmm kit. This is usually not a good idea, because
it includes a megabyte or so of headers, but for simple programs, it
suffices.
</para>

<para>
The next line:
</para>

<para>
<programlisting>
Gtk::Main kit(argc, argv);
</programlisting>
</para>

<para>
creates a <literal>Gtk::Main</literal> object.  This is needed in all gtkmm
applications. The constructor for this object initializes gtkmm,  and checks the
arguments passed to your application on the command line, looking for
standard options such as <literal>-display</literal>. It takes these from the argument list, leaving anything it does not
recognize for your application to parse or ignore.  This ensures 
that all gtkmm applications accept the same set of standard arguments.
</para>

<para>
The next two lines of code create and display a window:
</para>

<para>
<programlisting>
  Gtk::Window window;
</programlisting>
</para>

<para>
The last line shows the window and enters the gtkmm main processing loop, which will finish when the window is closed.
</para>

<para>
<programlisting>
  Gtk::Main::run(window);
</programlisting>
</para>

<para>
After putting the source code in <literal>simple.cc</literal> you can compile the above program with gcc using:
<programlisting>
g++ simple.cc -o simple `pkg-config gtkmm-2.4 --cflags --libs`
</programlisting>
Note that you must surround
the <literal>pkg-config</literal> invocation with backquotes.  
Backquotes cause the shell to execute the command inside them, and to use 
the command's output as part of the command line.
</para>
<para>
Although we have shown the compilation command for this simple example, you really should use the automake and autoconf tools, as described in "Autoconf, Automake, Libtool", by G. V. Vaughan et al. The examples used in this book are included in the gtkmm package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate directory and type <literal>make</literal>.
</para>
<para>
To simplify compilation, we use <literal>pkg-config</literal>, which
is present in all (properly installed) gtkmm installations.  This
program 'knows' what compiler switches are needed to compile programs
that use gtkmm.  The <literal>--cflags</literal> option causes
<literal>pkg-config</literal> to output a list of include directories for the
compiler to look in; the <literal>--libs</literal> option requests the
list of libraries for the compiler to link with and the directories to
find them in. Try running it from your shell-prompt to see the results on your system.
</para>
</sect1>

<sect1 id="sec-widgets">
<title>Widgets</title>
<para>gtkmm applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called "controls". For each widget in your application's windows, there is a C++ object in your application's code. So you just need to call a method of the widget's class to affect the visible widget.</para>
 <para>Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as Gtk::VBox, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 Gtk::Button widgets to a Gtk::VBox container widgets:
<programlisting>
m_box.pack_start(m_Button1);
m_box.pack_start(m_Button2);
</programlisting>
and here is how to add the Gtk::VBox, containing those buttons, to a Gtk::Frame, which has a visible frame and title:
<programlisting>
m_frame.add(m_box);
</programlisting>
</para>
<para>
Most of the chapters in this book deal with specific widgets. See the <link linkend="sec-ContainerWidgets">Container Widgets</link> section for more details about adding widgets to container widgets.
</para>

<para>Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design your user interfaces with <literal>Glade</literal> and load them at runtime with <literal>libglademm</literal>. See the <link linkend="sec-libglademm">Glade and libglademm</link> chapter.
</para>

<para>Although gtkmm widget instances have lifetimes and scopes just like those of other C++ classes, gtkmm has an optional time-saving feature that you will see in some of the examples. <literal>Gtk::manage()</literal> allows you to say that a child widget is owned by the container into which you place it. This is allows you to <literal>new()</literal> the widget, add it to the container and forget about deleting it. You can learn more about gtkmm memory management techniques in the <link linkend="sec-Memory">Memory Management chapter</link>.
</para>

</sect1>

<sect1 id="sec-signals">
<title>Signals</title>

<para>
gtkmm, like most GUI toolkits, is <emphasis>event-driven</emphasis>. When an event occurs, such as the press of a mouse
button, the appropriate signal will be <emphasis>emitted</emphasis> by the Widget
that was pressed. Each Widget has a different set of signals that it can emit. To make a
button click result in an action, we set up a
<emphasis>signal handler</emphasis> to catch the button's "clicked" signal.
</para>
<para>gtkmm uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "clicked" signal with a signal handler called "on_button_clicked":
<programlisting>
m_button1.signal_clicked().connect( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked) );
</programlisting>
</para>

<para>For more detailed information about signals, see the <link linkend="sec-appendix-signals">appendix</link>.</para> 
<para>For information about implementing your own signals rather than
just connecting to the existing gtkmm signals, see the <link linkend="sec-appendix-custom_signals">appendix</link>.</para> 

</sect1>

<sect1 id="sec-basics-ustring">
<title>Glib::ustring</title>
<para>You might be surprised to learn that gtkmm doesn't use std::string in it its interfaces. Instead it uses Glib::ustring, which is so similar and unobtrusive that you could actually pretend that each Glib::ustring is a std::string and ignore the rest of this section. But read on if you want to use languages other than English in your application.</para>
<para>std::string uses 8 bit per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese. Although the encodings for these languages has now been specified by the Unicode Constortium, the C and C++ languages do not yet provide any standardised Unicode support. GTK+ and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring. It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string.</para>
<para>One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. std::string will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using Glib::ustring instead.</para>
<para>Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "Gr&uuml;&szlig; Gott" would be "Gr\xC3\xBC\xC3\x9F Gott").</para>
<para>You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. Glib::ustring worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes.</para>

<para>Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones.</para>

<para><ulink url="&url_refdocs_base_glib;ustring.html">Reference</ulink></para>

<para>See the <link linkend="sec-internationalization">Internationalization</link> section for information about providing the UTF-8 string literals.</para> 

</sect1>

<sect1 id="sec-intermediatetypes">
<title>Intermediate types</title>
<para>Some parts of the <literal>gtkmm</literal> API use intermediate data containers, such as <literal>Glib::StringArrayHandle</literal> instead of a specific Standard C++ container such as <literal>std::vector</literal> or <literal>std::list</literal>. You should not declare these types yourself -- you should use whatever Standard C++ container you prefer instead. gtkmm will do the conversion for you. Here are some of these intermediate types:
<itemizedlist>
	<listitem><para>Glib::StringArrayHandle or Glib::ArrayHandle&lt;Glib::ustring&gt;: Use std::vector&lt;Glib::ustring&gt;, std::list&lt;Glib::ustring&gt;, const char*[], etc.</para></listitem>
<listitem><para>Glib::ListHandle&lt;Gtk::Widget*&gt;: Use std::vector&lt;Gtk::Widget*&gt;, std::list&lt;Gtk::Widget*&gt;, etc.</para></listitem>
<listitem><para>Glib::SListHandle&lt;Gtk::Widget*&gt;: Use std::vector&lt;Gtk::Widget*&gt;, std::list&lt;Gtk::Widget*&gt;, etc.</para></listitem>
</itemizedlist>

</para>

</sect1>

<sect1 id="sec-helloworld">
<title>Hello World in gtkmm</title>

<para>
We've now learned enough to look at a real example.  In accordance with an ancient
tradition of computer science, we now introduce Hello World, a la gtkmm:
</para>

<para><ulink url="&url_examples_base;helloworld">Source Code</ulink></para>

<para>
Try to compile and run it before going on. You should see something like this:
</para>

<figure id="figure-helloworld">
  <title>Hello World</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;helloworld.png"/>
  </screenshot>
</figure>

<para>
Pretty thrilling, eh?  Let's examine the code.  First, the
<literal>HelloWorld</literal> class:
</para>

<para>
<programlisting>
class HelloWorld : public Gtk::Window
{
 
public:
  HelloWorld();
  virtual ~HelloWorld();
  
protected:
  //Signal handlers:
  virtual void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};
</programlisting>
</para>

<para>
This class implements the "Hello World" window.  It's derived from
<literal>Gtk::Window</literal>, and has a single <literal>Gtk::Button</literal> as a member.
We've chosen to use the
constructor to do all of the initialisation work for the window,
including setting up the signals.  Here it is, with the comments
omitted:
</para>

<para>
<programlisting>
HelloWorld::HelloWorld()
:
  m_button ("Hello World")
{
  set_border_width(10);
  m_button.signal_clicked().connect(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked));
  add(m_button);.
  m_button.show();
}
</programlisting>
</para>

<para>
Notice that we've used an initialiser statement to give the <literal>m&lowbar;button</literal>
object the label &quot;Hello World&quot;.
</para>

<para>
Next we call the Window's <literal>set&lowbar;border&lowbar;width()</literal> method.  This sets
the amount of space between the sides of the window and the widget it
contains.
</para>

<para>
We then hook up a signal handler to <literal>m&lowbar;button</literal>'s <literal>clicked</literal> signal.
This prints our friendly greeting to <literal>stdout</literal>.
</para>

<para>
Next, we use the Window's <literal>add()</literal> method to put <literal>m&lowbar;button</literal> in
the Window.  (<literal>add()</literal> comes from <literal>Gtk::Container</literal>, which is
described in the chapter on container widgets.)  The <literal>add()</literal> method
places the Widget in the Window, but it doesn't display
the widget.  gtkmm widgets are always invisible when you create them - to display them, you must call their <literal>show()</literal> method, which
is what we do in the next line.
</para>


<para>
Now let's look at our program's <literal>main()</literal> function.  Here it is,
without comments:
</para>

<para>
<programlisting>
int main(int argc, char** argv)
{
  Gtk::Main kit(argc, argv);

  HelloWorld helloworld;
  Gtk::Main::run(helloworld);

  return 0;
}
</programlisting>
</para>

<para>
First we instantiate an object called <literal>kit</literal>. This is of type
<literal>Gtk::Main</literal>.  Every gtkmm program must have one of these.  We pass
our command-line arguments to its constructor. It takes the arguments
it wants, and leaves you the rest, as we described earlier.
</para>

<para>
Next we make an object of our <literal>HelloWorld</literal> class, whose constructor
takes no arguments, but it isn't visible yet. When we call Gtk::Main::run(), giving it the helloworld Window, it shows the Window and starts the gtkmm <emphasis>event loop</emphasis>. During the event loop gtkmm idles, waiting for actions from the user, and responding appropriately. When the user closes the Window, run() will return, causing the final line of our main() function be to executed. The application will then finish.
</para>

</sect1>
</chapter>


<chapter id="sec-buttonwidget">
<title>Buttons</title>

<para>
gtkmm provides four basic types of buttons:
</para>

<para>
<variablelist>

<varlistentry>
<term>Push-Buttons</term>
<listitem>
<para>
<ulink url="&url_refdocs_base_gtk;Button.html"><literal>Gtk::Button</literal></ulink>. Standard buttons, usually
marked with a label or picture. Pushing one triggers an action.  See the <link linkend="sec-Pushbuttons">Button</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Toggle buttons</term>
<listitem>
<para>
<ulink url="&url_refdocs_base_gtk;ToggleButton.html"><literal>Gtk::ToggleButton</literal></ulink>.
Unlike a normal Button, which springs back up, a ToggleButton stays down until you
press it again. It might be useful as an on/off switch.  See the <link linkend="sec-Toggle-Buttons">ToggleButton</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Checkboxes</term>
<listitem>
<para>
<ulink url="&url_refdocs_base_gtk;CheckButton.html"><literal>Gtk::CheckButton</literal></ulink>.
These act like ToggleButtons, but show their state in small squares,
with their label at the side. They should be used in most situations
which require an on/off setting.  
See the <link linkend="sec-Checkboxes">CheckBox</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Radio buttons</term>
<listitem>
<para>
<ulink url="&url_refdocs_base_gtk;RadioButton.html"><literal>Gtk::RadioButton</literal></ulink>.
Named after the station selectors on old car
radios, these buttons are used in groups for options which are
mutually exclusive. Pressing one causes all the
others in its group to turn off.  They are similar to
CheckBoxes (a small widget with a label at the side), but usually
look different.
See the <link linkend="sec-Radio-Buttons">RadioButton</link> section.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
Note that, due to GTK+'s theming system, the appearance of these
widgets will vary.  In the case of checkboxes and radio buttons, they
may vary considerably.
</para>

<sect1 id="sec-Pushbuttons">
<title>Button</title>

<sect2><title>Constuctors</title>

<para>
There are two ways to create a Button. You can specify a label
string in the <literal>Gtk::Button</literal> constructor,
or set it later with <literal>set_label()</literal>.
</para>

<para>To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <literal>true</literal> for the optional <literal>mnemonic</literal> parameter. For instance:
<programlisting>
Gtk::Button* pButton = new Gtk::Button("_Something", true);
</programlisting>
</para>

<para>
Wherever possible you should use Stock items, to ensure consistency with other applications, and to improve the appearance of your applications by using icons. For instance,
<programlisting>
Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);
</programlisting>
This will use standard text, in all languages, with standard keyboard accelerators, with a standard icon.
</para>

<para>
<literal>Gtk::Button</literal> is also
a container so you could put any other widget, such as a
<literal>Gtk::Image</literal> into it.
</para>

<para><ulink url="&url_refdocs_base_gtk;Button.html">Reference</ulink></para>
</sect2>

<sect2><title>Example</title>

<para>
This example creates a button with a picture and a label.
</para>

<figure id="figure-buttons">
  <title>buttons example</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;buttons.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;buttons/button">Source Code</ulink></para>

<para>
Note that the <literal>XPMLabelBox</literal> class can be used to place XPMs and
labels into any widget that can be a container.
</para>
</sect2>

<sect2><title>Signals</title>

<para>
The <literal>Gtk::Button</literal> widget has the following signals, but most of the time you will just handle the <literal>clicked</literal> signal:
</para>

<para>
<variablelist>

<varlistentry>
<term><literal>pressed</literal></term>
<listitem>
<para>
Emitted when the button is pressed.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>released</literal></term>
<listitem>
<para>
Emitted when the button is released.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>clicked</literal></term>
<listitem>
<para>
Emitted when the button is pressed and released.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>enter</literal></term>
<listitem>
<para>
Emitted when the mouse pointer moves over the button's window.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>leave</literal></term>
<listitem>
<para>
Emitted when the mouse pointer leaves the button's window.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

</sect2>
</sect1>

<sect1 id="sec-Toggle-Buttons">
<title>ToggleButton</title>

<para><literal>ToggleButton</literal>s are like normal <literal>Button</literal>s, but when clicked they remain activated, or pressed,  until clicked again.</para>

<para>
To retrieve the state of the <literal>ToggelButton</literal>, you can use the 
<literal>get&lowbar;active()</literal> method. This returns <literal>true</literal> if the button
is "down". You can also set the toggle button's state, with <literal>set&lowbar;active()</literal>. Note that, if you do this, and the state actually changes, it causes the
"clicked" signal to be emitted.  This is usually what you want.
</para>

<para>
You can use the <literal>toggled()</literal> method to toggle the button, rather than
forcing it to be up or down: This switches the button's state, and causes the <literal>toggled</literal> signal to be emitted.
</para>

<para>
<literal>Gtk::ToggleButton</literal> is most useful as a base class for the <literal>Gtk::CheckButton</literal> and <literal>Gtk::RadioButton</literal> classes.
</para>

<para><ulink url="&url_refdocs_base_gtk;ToggleButton.html">Reference</ulink></para>

</sect1>

<sect1 id="sec-Checkboxes">
<title>CheckButton</title>

<para>
<literal>Gtk::CheckButton</literal> inherits from <literal>Gtk::ToggleButton</literal>.  The only real difference between the two is <literal>Gtk::CheckButton</literal>'s
appearance. You can check, set, and toggle a checkbox using the same
member methods as for <literal>Gtk::ToggleButton</literal>.
</para>

<para><ulink url="&url_refdocs_base_gtk;CheckButton.html">Reference</ulink></para>

<sect2><title>Example</title>

<figure id="figure-checkbutton">
  <title>CheckButton</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;checkbutton.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;buttons/checkbutton">Source Code</ulink></para>
</sect2>

</sect1>

<sect1 id="sec-Radio-Buttons">
<title>RadioButton</title>

<para>
Like checkboxes, radio buttons also inherit from
<literal>Gtk::ToggleButton</literal>, but these work in groups, and only one RadioButton in a group can be selected at any one time.
</para>

<sect2><title>Groups</title>
<para>
There are two ways to set up a group of radio buttons.  The first way
is to create the buttons, and set up their groups afterwards.  Only
the first two constructors are used.  In the following example, we
make a new window class called <literal>RadioButtons</literal>, and then put three
radio buttons in it:
</para>

<para>
<programlisting>
  class RadioButtons : public Gtk::Window
  {
  public:
      RadioButtons();

  protected:
      Gtk::RadioButton m_rb1, m_rb2, m_rb3;
  };

  RadioButtons::RadioButtons()
    : m_rb1("button1"),
      m_rb2("button2"),
      m_rb3("button3")
  {
      Gtk::RadioButton::Group group = m_rb1.get_group();
      m_rb2.set_group(group);
      m_rb3.set_group(group);
  }
</programlisting>
We told gtkmm to put all three <literal>RadioButton</literal>s in the same group by obtaining the group with <literal>get_group()</literal> and using <literal>set_group()</literal> to tell the othe <literal>RadioButton</literal>s to share that group.
</para>

<para>
Note that you can't just do
<programlisting>m_rb2.set_group(m_rb1.get_group()); //doesn't work</programlisting>
because the group is modified by <literal>set_group()</literal> and therefore non-const.
</para>
 

<para>
The second way to set up radio buttons is to make a group first, and
then add radio buttons to it.  Here's an example:
<programlisting>
  class RadioButtons : public Gtk::Window
  {
  public:
      RadioButtons();
  };

  RadioButtons::RadioButtons()
  {
      Gtk::RadioButton::Group group;
      Gtk::RadioButton *m_rb1 = Gtk::manage( new Gtk::RadioButton(group,"button1"));
      Gtk::RadioButton *m_rb2 = manage( new Gtk::RadioButton(group,"button2"));
      Gtk::RadioButton *m_rb3 = manage( new Gtk::RadioButton(group,"button3"));
  }
</programlisting>
</para>

<para>
We made a new group by simply declaring a variable, <literal>group</literal>, of type
<literal>Gtk::RadioButton::Group</literal>.  Then we made three radio buttons, using
a constructor to make each of them part of <literal>group</literal>.
</para>
</sect2>

<sect2><title>Methods</title>
<para>
<literal>RadioButtons</literal> are "off" when created; this means that when you first
make a group of them, they will all be off. Don't forget to turn one of them
on using <literal>set&lowbar;active()</literal>:
</para>

<para><ulink url="&url_refdocs_base_gtk;RadioButton.html">Reference</ulink></para>

</sect2>

<sect2><title>Example</title>
<para>
The following example demonstrates the use of <literal>RadioButton</literal>s:
</para>

<figure id="figure-radiobutton">
  <title>RadioButton</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;radiobuttons.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;buttons/radiobutton">Source Code</ulink></para>

</sect2>

</sect1>

</chapter>


<chapter id="sec-Range-Widgets">
<title>Range Widgets</title>

<para>
<literal>Gtk::Scale</literal> and <literal>Gtk::Scrollbar</literal> both inherit from <literal>Gtk::Range</literal> and share much functionality. They contain a "trough" and a "slider" (sometimes
called a "thumbwheel" in other GUI environments). Dragging the slider
with the pointer moves it within the trough, while
clicking in the trough advances the slider towards the location of the
click, either completely, or by a designated amount, depending on
which mouse button is used. This should be familiar scrollbar behaviour.
</para>

<para>
As will be explained in the <link linkend="sec-Adjustment">Adjustment</link> section,
all Range widgets are associated with a <literal>Adjustment</literal> object. To change the lower, upper, and current values used by the widget you need to use the methods of its <literal>Adjustment</literal>, which you can get with the <literal>get_adjustment()</literal> method. The <literal>Range</literal> widgets' default constructors create an <literal>Adjustment</literal> automatically, or you can specify an existing <literal>Adjustment</literal>, maybe to share it with another widget. See the <link linkend="sec-Adjustment">Adjustments</link> section for further details
</para>

<para><ulink url="&url_refdocs_base_gtk;Range.html">Reference</ulink></para>

<sect1>
<title>Scrollbar Widgets</title>

<para>
These are standard scrollbars. They should be
used only to scroll another widget, such as, a <literal>Gtk::Entry</literal>,
or a <literal>Gtk::Viewport</literal>, though it's usually easier to use the <literal>Gtk::ScrolledWindow</literal>
widget in most cases.
</para>

<para>
There are horizontal and vertical scrollbar classes - <literal>Gtk::HScrollbar</literal> and <literal>Gtk::VScrollbar</literal>.
</para>

<para><ulink url="&url_refdocs_base_gtk;Scrollbar.html">Reference</ulink></para>

</sect1>

<sect1 id="sec-scale_widgets">
<title>Scale Widgets</title>

<para>
<literal>Gtk::Scale</literal> widgets (or "sliders") allow the user to
visually select and manipulate a value within a specific range. You
might use one, for instance, to adjust the
magnification level on a zoomed preview of a picture, or to control
the brightness of a colour, or to specify the number of minutes of
inactivity before a screensaver takes over the screen.
</para>

<para>
As with <literal>Scrollbars</literal>, there are separate widget types for horizontal and
vertical widgets - <literal>Gtk::HScale</literal> and <literal>Gtk::VScale</literal>. The default constructors create an <literal>Adjustment</literal> with all of its values set to <literal>0.0</literal>. This isn't useful so you will need to set some <literal>Adjustment</literal> details to get meaningful behaviour. 
</para>

<sect2>
<title>Useful methods</title>

<para>
<literal>Scale</literal> widgets can display their current value as a number next to the
trough. By default they show the value, but you can change
this with the <literal>set_draw_value()</literal> method.
</para>

<para>
The value displayed by a scale widget is rounded to one decimal point
by default, as is the <literal>value</literal> field in its <literal>Gtk::Adjustment</literal>. You can
change this with the <literal>set_digits()</literal> method.
</para>

<para>
Also, the value can be drawn in different positions
relative to the trough, specified by the <literal>set_value_pos()</literal> method.
</para>

<para><ulink url="&url_refdocs_base_gtk;Scale.html">Reference</ulink></para>

</sect2>
</sect1>

<sect1 id="sec-update_policies">
<title>Update Policies</title>

<para>
The <emphasis>update policy</emphasis> of a <literal>Range</literal> widget defines at what points during
user interaction it will change the <literal>value</literal> field of its
<literal>Gtk::Adjustment</literal> and emit the <literal>value&lowbar;changed</literal> signal. The update policies, set with the <literal>set_update_policy()</literal> method, are:

<itemizedlist>
<listitem>

<para>
<literal>Gtk::UPDATE&lowbar;CONTINUOUS</literal> - This is the default. The
<literal>value&lowbar;changed</literal> signal is emitted continuously, i.e. whenever the
slider is moved by even the tiniest amount.
</para>
</listitem>
<listitem>

<para>
<literal>Gtk::UPDATE&lowbar;DISCONTINUOUS</literal> - The <literal>value&lowbar;changed</literal> signal is
only emitted once the slider has stopped moving and the user has
released the mouse button.
</para>
</listitem>
<listitem>

<para>
<literal>Gtk::UPDATE&lowbar;DELAYED</literal> - The <literal>value&lowbar;changed</literal> signal is emitted
when the user releases the mouse button, or if the slider stops moving
for a short period of time.
</para>
</listitem>

</itemizedlist>

</para>
</sect1>

<sect1 id="sec-Range-Example">
<title>Example</title>

<para>
This example displays a window with three range widgets all connected
to the same adjustment, along with a couple of controls for adjusting
some of the parameters mentioned above and in the section on
adjustments, so you can see how they affect the way these widgets work
for the user.
</para>

<figure id="figure-range_widgets">
  <title>Range Widgets</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;range_widgets.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;range_widgets">Source Code</ulink></para>

</sect1>

</chapter>

<chapter id="sec-miscwidgets">
<title>Miscellaneous Widgets</title>

<sect1 id="sec-Labels">
<title>Label</title>

<para>
Labels are the  main method of placing non-editable
text in windows, for instance to place a title next to a <literal>Entry</literal> widget. You can specify the text in the constructor, or with the <literal>set_text()</literal> method.
</para>

<para>
The width of the label will be adjusted automatically.  You can produce multi-line labels by putting line breaks ("\n") in the label string.
</para>

<para>
The label text can be justified using the <literal>set_justify()</literal> method. The widget is also capable of word-wrapping - this can be activated with <literal>set_line_wrap()</literal>.
</para>

<para>
TODO: gtkmm2: markup.
</para>

<para><ulink url="&url_refdocs_base_gtk;Label.html">Reference</ulink></para>

<sect2><title>Example</title>
<para>
Below is a short example to illustrate these functions. This example
makes use of the Frame widget to better demonstrate the label styles.
 (The Frame widget is explained in the <link linkend="sec-Frame">Frame</link> section.)
</para>

<figure id="figure-label">
  <title>Label</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;label.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;label">Source Code</ulink></para>

</sect2>

</sect1>

<sect1 id="sec-TextEntries">
<title>Entry</title>

<para>
Entry widgets allow the user to enter text (surprisingly
enough).
</para>

<para>
You can change the contents with the <literal>set_text()</literal> method, and read the current contents with the <literal>get_text()</literal> method.
</para>

<para>
Occasionally you might want to make an <literal>Entry</literal> widget read-only.
This can be done by passing <literal>false</literal> to the <literal>set_editable()</literal> method.
</para>

<para>
For the input of
passwords, passphrases and other information you don't want echoed
on the screen,  calling <literal>set_visibility()</literal> with <literal>false</literal> will cause the text to be hidden.
</para>

<para>
You might want to be notified whenever the user types in a text entry
widget.  <literal>Gtk::Entry</literal> provides two signals, <literal>activate</literal> and
<literal>changed</literal>, for just this purpose.  <literal>activate</literal> is emitted when
the user presses the enter key in a text-entry widget; <literal>changed</literal> is
emitted when the text in the widget changes.  You can use these, for instance, to
validate or filter the text the user types.
</para>

<para><ulink url="&url_refdocs_base_gtk;Entry.html">Reference</ulink></para>

<sect2><title>Example</title>
<para>
Here is an example using <literal>Gtk::Entry</literal>.  As well as a
<literal>Gtk::Entry</literal> widget, it has two <literal>CheckButton</literal>s, with which you can toggle the
editable and visible flags.
</para>

<figure id="figure-entry">
  <title>Entry</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;entry.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;entry">Source Code</ulink></para>

</sect2>

</sect1>

<sect1 id="sec-ComboBoxes">
<title>Combo</title>

<para>
A <literal>Combo</literal> is a combination of a text entry and a popup menu. Clicking on one of the
menu entries puts it in the entry box.  The entry box otherwise works
just like a regular <literal>Entry</literal> widget.
</para>

<para>
A <literal>Gtk::Combo</literal> contains a <literal>Gtk::Entry</literal> widget, which is used to
implement the entry box.  You can obtain the <literal>Gtk::Entry</literal> using <literal>get_entry()</literal> method.
</para>

<para>
To set the values in the popup menu, use
<programlisting>
void Gtk::Combo::set_popdown_strings(const Gtk::SArray&amp; strings);
</programlisting>
where <literal>strings</literal> is a list of the strings you want to appear in the
list.  As mentioned in the <link linkend="sec-intermediatetypes">Basics</link> section, <literal>Gtk::SArray</literal> is a converter object which can take any
kind of STL vector container. This means that you can pass vectors or
lists to this method, and things will work as you expect.  For
example, the following is legal:
</para>

<para>
<programlisting>
list&lt;string&gt; gl;

gl.push_back("String 1");
gl.push_back("String 2");
gl.push_back("String 3");
gl.push_back("String 4");

combo.set_popdown_strings(gl);
</programlisting>
</para>

<para>TODO: STL-style access.</para>

<para><ulink url="&url_refdocs_base_gtk;RadioButton.html">Reference</ulink></para>

<sect2><title>Example</title>

<figure id="figure-combo">
  <title>Combo</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;combo.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;combo">Source Code</ulink></para>

</sect2>

</sect1>

<sect1 id="sec-Spinbuttons">
<title>SpinButton</title>

<para>
A <literal>SpinButton</literal> allows the user to select a value from a range of
numeric values. It has an Entry widget with up and down arrow
buttons at the side. Clicking the buttons causes the
value to 'spin' up and down across the range of possible values. The
<literal>Entry</literal> widget may also be used to enter a value directly.
</para>

<para>
The value can have an adjustable number of decimal places,
and the step size is configurable. <literal>SpinButton</literal>s have an 'auto-repeat'
feature as well: holding down one of the arrows can optionally cause
the value to change more quickly the longer the arrow is held down.
</para>

<para>
<literal>SpinButton</literal>s use an <link linkend="sec-Adjustment">Adjustment</link>
object to hold information about the range of values. These Adjustment attributes are used by the Spin Button like so:
<itemizedlist>
<listitem>

<para>
 <literal>value</literal>: value for the Spin Button
</para>
</listitem>
<listitem>

<para>
 <literal>lower</literal>: lower range value
</para>
</listitem>
<listitem>

<para>
 <literal>upper</literal>: upper range value
</para>
</listitem>
<listitem>
<para>
 <literal>step&lowbar;increment</literal>: value to increment/decrement when pressing
mouse button 1 on a button
</para>
</listitem>
<listitem>

<para>
 <literal>page&lowbar;increment</literal>: value to increment/decrement when pressing
mouse button 2 on a button
</para>
</listitem>
<listitem>

<para>
 <literal>page&lowbar;size</literal>: unused
</para>
</listitem>

</itemizedlist>
</para>

<para>
Additionally, mouse button 3 can be used to jump directly to the
<literal>upper</literal> or <literal>lower</literal> values.
</para>

<para>The <literal>SpinButton</literal> can create a default <literal>Adjustment</literal>, which you can access via the <literal>get_adjustment()</literal> method, or you can specify an existing <literal>Adjustment</literal> in the constructor.
</para>


<sect2><title>Methods</title>

<para>
The number of decimal places can be altered using the <literal>set_digits()</literal> method.
</para>

<para>
You can set the spinbutton's value using the <literal>set_value()</literal> method, and retrieve it with <literal>get_value()</literal>.
</para>

<para>
The <literal>spin()</literal> method 'spins' the <literal>SpinButton</literal>, as
if one of its arrows had been clicked. You need to specify a <literal>Gtk::SpinType</literal> to specify the direction or new position.
</para>

<para>
To prevent the user from typing non-numeric characters into the entry
box, pass <literal>true</literal> to the <literal>set_numeric()</literal> method.
</para>

<para>
To make the <literal>SpinButton</literal> 'wrap' between its upper and lower
bounds, use the <literal>set_wrap()</literal> method.</para>

<para>
To force it to snap to the nearest
<literal>step&lowbar;increment</literal>, use <literal>set_snap_to_ticks</literal>
</para>

<para>
You can modify the update policy using the <literal>set_update_policy</literal> method, specifying either <literal>Gtk::UPDATE_ALWAYS</literal> or <literal>Gtk::UPDATE_IF_VALID</literal>. <literal>Gtk::UPDATE&lowbar;ALWAYS</literal> causes the
<literal>SpinButton</literal> to ignore errors encountered while converting the text in
the entry box to a numeric value.  This setting also therefore allows
the <literal>SpinButton</literal> to accept non-numeric values. You can force an immediate update using the <literal>update()</literal> method.
</para>

<para><ulink url="&url_refdocs_base_gtk;SpinButton.html">Reference</ulink></para>

</sect2>

<sect2><title>Example</title>

<para>
Here's an example of a <literal>SpinButton</literal> in action:
</para>

<figure id="figure-spinbutton">
  <title>SpinButton</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;spinbutton.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;spinbutton">Source Code</ulink></para>

</sect2>

</sect1>

<sect1 id="sec-ProgressBar">
<title>ProgressBar</title>

<para>
Progress bars are used to show the status of an ongoing operation. For instance, a <literal>ProgressBar</literal> can show how much of a task has been completed.
</para>

<para>To change the value shown, use the <literal>set_fraction()</literal> method, passing a double between 0 and 1 to provide the new percentage.</para>

<para>
where <literal>percentage</literal> is a number, from 0 to 1, indicating what
fraction of the bar should be filled.
</para>

<para>
A <literal>ProgressBar</literal>is horizontal and left-to-right by default, but you can change it to a vertical progress bar by using the <literal>set_orientation()</literal> method.
</para>

<para><ulink url="&url_refdocs_base_gtk;ProgressBar.html">Reference</ulink></para>

<sect2>
<title>Activity Mode</title>
<para>
Besides indicating the amount of progress that has occured, the
progress bar can also be used to indicate that there is some activity;
this is done by placing the progress bar in <emphasis>activity mode</emphasis>.  In
this mode, the progress bar displays a small rectangle which moves
back and forth.  Activity mode is useful in situations where the
progress of an operation cannot be calculated as a value range (e.g.,
receiving a file of unknown length).
</para>

<para>
To do this, you need to call the <literal>pulse()</literal> method at regular intervals. You can also choose the step size, with the <literal>set_pulse_step()</literal> method.
</para>

<para>
When in continuous mode, the progress bar can also display a
configurable text string within its trough, using the <literal>set_text()</literal> method.
</para>
</sect2>

<sect2><title>Example</title>

<figure id="figure-progressbar">
  <title>ProgressBar</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;progressbar.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;progressbar">Source Code</ulink></para>

</sect2>

</sect1>

<sect1 id="sec-Tooltips">
<title>Tooltips</title>

<para>
<literal>Tooltips</literal> are the little text strings that pop up when you leave your
pointer over a widget for a few seconds and the <literal>Gtk::Tooltips</literal> object is a group of these tooltips. After creating a <literal>Gtk::Tooltips</literal> instance, you can use the <literal>set_tip()</literal> method to associate some descriptive text with a <literal>Widget</literal>.
</para>

<para>The <literal>enable()</literal> and <literal>disable()</literal> methods allow you to turn a whole group of tooltips on and off.</para>

<para><ulink url="&url_refdocs_base_gtk;Tooltips.html">Reference</ulink></para>

</sect1>

</chapter>

<chapter id="sec-ContainerWidgets">
<title>Container Widgets</title>

<para>All container widgets derive from <literal>Gtk::Container</literal>, not always directly. Some container widgets, such as <literal>Gtk::Table</literal> can hold many child widgets, so these typically have more complex interfaces. Others, such as <literal>Gtk::Frame</literal> contain only one child widget.
</para>

<sect1 id="sec-SingleItemWidgets">
<title>Single-item Containers</title>

<para>The single-item container widgets derive from <literal>Gtk::Bin</literal>, which provides the <literal>add()</literal> and <literal>remove()</literal> methods for the child widget. Note that <literal>Gtk::Button</literal> and <literal>Gtk::Window</literal> are technically single-item containers, but we have discussed them already elsewhere. 
</para>

<para>
We also discuss the <literal>Gtk::Paned</literal> widget, which allows you to divide
a window into two separate "panes".  This widget actually contains two
child widgets, but the number is fixed so it seems appropriate.
</para>

<sect2 id="sec-Frame">
<title>Frame</title>

<para>
Frames can enclose one or a group of widgets within a box, optionally with a title. For instance, you might place a group of <literal>RadioButton</literal>s or <literal>CheckButton</literal>s in a <literal>Frame</literal>.
</para>

<para><ulink url="&url_refdocs_base_gtk;Frame.html">Reference</ulink></para>

<sect3><title>Example</title>

<figure id="figure-frame">
  <title>Frame</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;frame.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;frame">Source Code</ulink></para>

</sect3>

</sect2>


<sect2>
<title>Paned</title>

<para>
Panes divide a widget into two halves, separated by a moveable
divider.  There are two such widgets: <literal>Gtk::HPaned</literal> adds a
horizontal divider, and <literal>Gtk::VPaned</literal> adds a vertical one.  Other
than the names and the orientations, there's no difference between the
two.
</para>

<para>
Unlike the other widgets in this chapter, pane widgets contain not
one but two child widgets, one in each pane. Therefore, you should use <literal>add1()</literal> and <literal>add2()</literal>
instead of the <literal>add()</literal> method.</para>

<para>
You can adjust the position of the divider using the <literal>set_position()</literal> method, and you will probably need to do so.
</para>

<para><ulink url="&url_refdocs_base_gtk;Paned.html">Reference</ulink></para>

<sect3><title>Example</title>

<figure id="figure-paned">
  <title>Paned</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;paned.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;paned">Source Code</ulink></para>

</sect3>

</sect2>

<sect2 id="sec-ScrolledWindows">
<title>ScrolledWindow</title>

<para>
<literal>ScrolledWindow</literal> widgets are used to create a scrollable area.  You can insert any type of widget into a <literal>ScrolledWindow</literal> window, and
it will be accessible regardless of its size by using the scrollbars. Note that <literal>ScrolledWindow</literal> is not a <literal>Gtk::Window</literal> despite the slightly misleading name.
</para>

<para>
Scrolled windows have <emphasis>scrollbar policies</emphasis> which determine whether
the <literal>Scrollbar</literal>s will be displayed. The policies can be set with the <literal>set_policy()</literal> method. The policy may be one of <literal>Gtk::POLICY&lowbar;AUTOMATIC</literal> or <literal>Gtk::POLICY&lowbar;ALWAYS</literal>.
<literal>Gtk::POLICY&lowbar;AUTOMATIC</literal> will cause the scrolled window to display
the scrollbar only if the contained widget is larger than the visible area. 
<literal>Gtk::POLICY&lowbar;ALWAYS</literal> will cause the scrollbar to be displayed always.
</para>

<para><ulink url="&url_refdocs_base_gtk;ScrolledWindow.html">Reference</ulink></para>

<sect3><title>Example</title>

<para>
Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react.
</para>

<figure id="figure-scrolledwindow">
  <title>ScrolledWindow</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;scrolledwindow.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;scrolledwindow">Source Code</ulink></para>

</sect3>

</sect2>

<sect2 id="sec-AspectFrames">
<title>AspectFrame</title>

<para>
The <literal>AspectFrame</literal> widget looks like a <literal>Frame</literal> widget, but it also
enforces the <emphasis>aspect ratio</emphasis> (the ratio of the width to the
height) of the child widget, adding extra
space if necessary. For instance, this would allow you to display a photograph without allowing the user to distort it horizontally or vertically while resizing.
</para>

<para><ulink url="&url_refdocs_base_gtk;AspectFrame.html">Reference</ulink></para>

<sect3>
<title>Example</title>
<para>
The following program uses a <literal>Gtk::AspectFrame</literal> to present a drawing area whose aspect ratio will always be 2:1, no matter how the user resizes the top-level window.</para>

<para>TODO: screenshot</para>

<para><ulink url="&url_examples_base;aspectframe">Source Code</ulink></para>
</sect3>

</sect2>


<sect2 id="sec-Alignment">
<title>Alignment</title>

<para>
The <literal>Alignment</literal> widget allows you to place a widget at
a position and size relative to the size of the <literal>Alignment</literal> widget
itself.  For instance, it might be used to center a widget.
</para>

<para>
You need to specify the <literal>Alignment</literal>'s characteristics to the constructor, or to the <literal>set()</literal> method. In particular, you won't notice much effect unless you specify a number other than 1.0 for the <literal>xscale</literal> and <literal>yscale</literal> parameters, because 1.0 simply means that the child widget will expand to fill all available space.
</para>

<para><ulink url="&url_refdocs_base_gtk;Alignment.html">Reference</ulink></para>

<sect3>
<title>Example</title>
<para>
This example right-aligns a button in a window by using an <literal>Alignment</literal> widget.
</para>

<figure id="figure-alignment">
  <title>Alignment</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;alignment.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;alignment">Source Code</ulink></para>

<para>
See the <link linkend="sec-ProgressBar">ProgressBar</link> section for another example that uses an <literal>Alignment</literal>.</para>

</sect3>

</sect2>

</sect1>

<sect1 id="sec-MultiItemWidgets">
<title>Multiple-item widgets </title>

<para>
 Multiple-item widgets inherit from <literal>Gtk::Container</literal>; just as
with <literal>Gtk::Bin</literal>, you use the <literal>add()</literal> and <literal>remove()</literal> methods
to add and remove contained widgets.  Unlike <literal>Gtk::Bin::remove()</literal>,
however, the <literal>remove()</literal> method for <literal>Gtk::Container</literal> takes an
argument, specifiying which widget to remove.
</para>

<sect2>
<title>Packing</title>
<para>
You've probably noticed that gtkmm windows seem "elastic" - they can usually be stretched in many  different ways.  This is due to the <emphasis>widget packing</emphasis>
system.
</para>

<para>
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
</para>

<para>
<itemizedlist>

<listitem>
<para>The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.</para>
</listitem>

<listitem>
<para>It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.</para>
</listitem>

<listitem>
<para>
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It  requires tedious recalculation of every widget's position.</para>
</listitem>

</itemizedlist>
</para>

<para>
gtkmm uses the packing system to solve these problems.  Rather than specifying the position and size of each widget in the window,
you can arrange your widgets in rows, columns,
and/or tables. gtkmm can size your window automatically, based on the
sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets.
You can perfect your layout by
specifying padding distance and centering values for each of your widgets. gtkmm then uses
all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window. </para>

<para>
gtkmm arranges widgets hierarchically, using <emphasis>containers</emphasis>.  A
Container widget contains other widgets.  Most gtkmm widgets
are containers. Windows, Notebook tabs, and Buttons are all
container widgets.  There are two flavours of containers:
single-child containers, which are all descendants of <literal>Gtk::Bin</literal>,
and multiple-child containers, which are descendants of
<literal>Gtk::Container</literal>.  Most widgets in gtkmm are descendants of
<literal>Gtk::Bin</literal>, including <literal>Gtk::Window</literal>.
</para>

<para>
Yes, that's correct: a Window can contain at most one widget.
How, then, can we use a window for anything useful?  By placing a
multiple-child container in the window. The most useful container widgets are Gtk:VBox, Gtk::HBox, and Gtk::Table:
</para>

<para>

<itemizedlist>

<listitem>
<para>
<literal>Gtk::VBox</literal> and <literal>Gtk::HBox</literal> arrange their child widgets vertically and horizontally, respectively. Use pack_start() and pack_end() to insert child widgets.
</para>
</listitem>

<listitem>
<para>
<literal>Gtk::Table</literal> arranges its widgets in a grid. Use attach() to insert widgets.
</para>
</listitem>

</itemizedlist>
</para>

<para>
 There are several other containers, which we will also discuss.
</para>

<para>
If you've never used a packing toolkit before, it can take some
getting used to.  You'll probably find, however, that you don't
need to rely on visual form editors quite as much as you might with
other toolkits.
</para>

</sect2>

<sect2 id="sec-helloworld2">
<title>An improved Hello World</title>

<para>
 Let's take a look at a slightly improved <literal>helloworld</literal>, showing what we've learnt.
</para>

<figure id="figure-helloworld2">
  <title>Hello World 2</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;helloworld2.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;helloworld2">Source Code</ulink></para>

<para>
After building and running this program, try resizing the window to see the behaviour. Also, try
playing with the options to <literal>pack&lowbar;start()</literal> while reading the <link linkend="sec-Boxes">Boxes</link> section.
</para>

</sect2>

<sect2 id="sec-stl-style">
<title>STL-style APIs</title>

<para>
TODO: Use 'Standard Library' instead of STL.
If you're an accomplished C++ programmer, you'll be happy to hear that
most of the gtkmm <literal>Container</literal> widgets provide STL-style APIs, available via accessor methods, such as <literal>Gtk::Box::children()</literal> or <literal>Gtk::Notebook::pages()</literal>. They don't 
use actual STL containers (there are good reasons for this), but they look, feel, and act much like STL
container classes.
</para>

<para>These APIs are so similar to STL container APIs that, rather than explaining them in detail, we can refer
you to the STL documentation for most of their methods. This is all part of gtkmm's policy of reusing existing standards.
</para>

<para>However, STL-style APIs can require awkward or lengthy code in some situations, so some people prefer not to use them, while other people use them religiously. Therefore, you are not forced to use them - most container widgets have a simpler non-STL-style API, with methods such as <literal>append()</literal> and <literal>prepend()</literal>. 
</para>

<para>
At a minimum, gtkmm container lists support iterators and the usual insertion, deletion, and addition methods.  You can
always expect the following methods to be available for gtkmm STL-style APIs:
<itemizedlist>

<listitem>
<para>
<literal>begin()</literal> returns a <literal>begin</literal> iterator
</para>
</listitem>

<listitem>
<para>
<literal>end()</literal> returns an <literal>end</literal> iterator
</para>
</listitem>

<listitem>
<para>
<literal>rbegin()</literal> returns a reverse <literal>begin</literal> iterator
</para>
</listitem>

<listitem>
<para>
<literal>rend()</literal> returns a reverse <literal>end</literal> iterator
</para>
</listitem>

<listitem>
<para>
<literal>size()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>max&lowbar;size()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>empty()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>insert()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>push&lowbar;front()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>push&lowbar;back()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>pop&lowbar;front()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>pop&lowbar;back()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>clear()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>erase()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>remove()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>find()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>front()</literal>
</para>
</listitem>

<listitem>
<para>
<literal>back()</literal>
</para>
</listitem>

</itemizedlist>

</para>

<para>
Also, the <literal>[]</literal> operator is overloaded, but that is usually order
N, so if performance is a consideration, or the list has a large
number of elements, think carefully before using it.
</para>

<para>
The element objects and list objects are defined, for each container,
in a namespace whose name ends in <literal>&lowbar;Helpers</literal>.  For example, the
helper namespace for the notebook widget is 
<literal>Gtk::Notebook&lowbar;Helpers</literal>.</para>


<sect3>
<title>Adding items</title>
<para>
There is a major difference between gtkmm STL-style APIs and
real STL containers.  Normally, when you use a <literal>std::vector</literal>, for example,
you expect that whatever you put in, you'll get out, unmodified.  You
wouldn't make a <literal>std::vector&lt;int&gt;</literal> and expect to get <literal>double</literal>s
out of it.  But, gtkmm STL-style APIs don't always work like
that - you will often put one kind of object in, and later get a different kind out.  Why this odd
behaviour?
</para>

<para>
Consider a menu widget, which must maintain a hierarchical list of
menus and menu items.  Menus can only contain certain objects, such as menu items, separators,
and submenus.  To ensure consistency, a "filter" is needed to
keep out illegal objects.  Also, since only a few types of objects are
allowed, convenience methods can be provided to make it easy to
build up menus.
</para>

<para>
gtkmm takes care of both requirements using special
<emphasis>helper elements</emphasis>.  Helper elements are
temporary - they're typically constructed and passed to an insertion method in the same call.
 The list insertion method uses the information in the helper element to construct the real
object, which is then inserted into the container.
</para>

<para>
As an example, let's look at the <literal>Notebook</literal> widget (explained in the
section on <link linkend="sec-Notebook">Notebooks</link>). Notebook widgets contain a series of "pages".
</para>

<para>
Each page in a notebook requires, at minimum, the following
information:
</para>

<para>
<itemizedlist>

<listitem>
<para>
A child widget (zero or one), to be placed in the page
</para>
</listitem>

<listitem>
<para>
A label for the page's tab
</para>
</listitem>

</itemizedlist>
</para>

<para>
(The gtkmm notebook widget keeps other data for each page as well.)
</para>

<para>
To insert a new page in a notebook, we can use one of the notebook
helper classes, like this:
<programlisting>
notebook-&#62;pages().push_back(
          Gtk::Notebook_Helpers::TabElem(*frame, bufferl));
</programlisting>
</para>

<para>
Let's see what's
going on here.  Assume we have a pointer to a Notebook widget called
<literal>notebook</literal>; we go from that to a member method called
<literal>pages()</literal>, which returns an STL-like list object.  On this we call
the method <literal>push&lowbar;back()</literal> (this should be familiar to those who know STL).
</para>

<para>
The object that the <literal>pages()</literal> method returns is called a
<literal>Notebook&lowbar;Helpers::PageList</literal>.  It's one of the STL-like containers
that we keep referring to.  Let's take a look at this class (this has been heavily edited for clarity; see
<literal>&lt;gtkmm/notebook.h&gt;</literal> for the actual definition):
</para>

<para>
<programlisting>
namespace Notebook_Helpers
{
    class PageList
    {
    public:
             . . .
        void push_back(const Element&#38; e);
             . . .
        Page* operator[](size_type l);
    };
};
</programlisting>
</para>

<para>
There are two important things to notice here:
<itemizedlist>

<listitem>
<para>
The <literal>push&lowbar;back()</literal> method takes as argument an <literal>Element</literal>
object (helper);
</para>
</listitem>

<listitem>
<para>
The overloaded <literal>[]</literal> operator returns a pointer to a
<literal>Page</literal>.
</para>

</listitem>

</itemizedlist>
</para>

<para>
This scheme has some important advantages:
</para>

<para>
<itemizedlist>

<listitem>
<para>
We can provide as many different Helper objects as desired,
making it simple to construct complex widgets like Menus.

</para>
</listitem>

<listitem>
<para>
Construction of the actual objects can be delayed until an appropriate time. Sometimes we don't have enough information until later
with GTK+.
</para>
</listitem>

<listitem>
<para>
The definitions of the objects contained in the list can change;
their interfaces need not concern the programmer.  For example, even
if the <literal>Page</literal> object changes drastically, the programmer need not
be concerned; the <literal>Element</literal>s need not change, and will continue to
work as expected.
</para>
</listitem>

<listitem>
<para>
New <literal>Element</literal> objects can be added at any time to support new
features, without breaking existing code.
</para>
</listitem>

</itemizedlist>
</para>

<para>
All multi-item containers have an <literal>Element</literal> object in their helper
namespaces, and usually there are additional classes
available (like <literal>TabElem</literal> and <literal>MenuElem</literal>) which derive from
<literal>Element</literal>.  <literal>Element</literal> classes vary from container to container,
since each contains different kinds of objects.
</para>

<para>
It's very important to remember that <literal>Element</literal>s are
not "real" objects. They exist only temporarily, and they are
never stored in the container.  They are used <emphasis>only</emphasis> as
temporary "parameter-holders".  Therefore, the following segment of
code is illegal:
<programlisting>
MenuElem* m = new MenuElem("hello");
m-&#62;right_justify();
items().push_back(*m);
</programlisting>
</para>

<para>
We constructed a new <literal>MenuElem</literal> helper object, and then
tried to invoke <literal>right&lowbar;justify()</literal> on it before adding it to the
menu.  The trouble is that there is no <literal>right&lowbar;justify()</literal> method
in the <literal>MenuElem</literal> class.  The correct way to accomplish this would
be:
<programlisting>
items().push_back(MenuElem("hello"));
items().back()-&#62;right_justify();
</programlisting>
</para>

<para>
Here, we've constructed a <literal>MenuElem</literal> and inserted it into the menu
by passing it to <literal>push&lowbar;back()</literal>, causing the real menu item to
be created.  We've then called <literal>right&lowbar;justify()</literal> on the object
retrieved from the list.  This is correct - the object retrieved from
the list is not a <literal>MenuElem</literal>, but a real <literal>MenuItem</literal>, and therefore supports the
<literal>right&lowbar;justify()</literal> method as expected.
</para>

</sect3>

</sect2>

<sect2 id="sec-Boxes">
<title>Boxes</title>

<para>
Most packing uses boxes as in the above example. These
are invisible containers into which we can pack our widgets. When
packing widgets into a horizontal box, the objects are inserted
horizontally from left to right or right to left depending on whether <literal>pack_start()</literal> or <literal>pack_end()</literal> is used. In a vertical box, widgets are packed from top to bottom or vice
versa. You may use any combination of boxes inside or beside other
boxes to create the desired effect.
</para>

<sect3><title>Adding widgets</title>
<sect4><title>Per-child packing options</title>
<para>
 The <literal>pack&lowbar;start()</literal> and
<literal>pack&lowbar;end()</literal> methods place widgets inside
these containers. The <literal>pack&lowbar;start()</literal> method will start at
the top and work its way down in a <literal>VBox</literal>, or pack left to right in an
<literal>HBox</literal>.  <literal>pack&lowbar;end()</literal> will do the opposite, packing from
bottom to top in a <literal>VBox</literal>, or right to left in an <literal>HBox</literal>. Using these
methods allows us to right justify or left justify our widgets. We will
use <literal>pack&lowbar;start()</literal> in most of our examples.
</para>

<para>
There are several options governing how  widgets are to be packed, and this can be confusing at first. If you have difficulties then it is sometimes a good idea to play with the <literal>glade</literal> GUI designer to see what is possible. You might even decide to use the <literal>libglademm</literal> API to load your GUI at runtime.
</para>

<para>
There are basically five
different styles, as shown in this picture:
</para>

<figure id="figure-box_packing1">
  <title>Box Packing 1</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;box_packing1.png"/>
  </screenshot>
</figure>

<para>
Each line contains one horizontal box (<literal>HBox</literal>) with several
buttons. Each of the buttons on a line is packed into the <literal>HBox</literal> with the same arguments to the
<literal>pack&lowbar;start()</literal> method).
</para>

<para>
This is the declaration of the <literal>pack&lowbar;start()</literal> method:
<programlisting>
void pack_start(Gtk::Widget&amp; child, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0);
</programlisting>
</para>

<para>
The first argument is the widget you're packing. In our example these are all <literal>Buttons</literal>s.
</para>

<para>
The <literal>options</literal> argument can take one of these three options:
<itemizedlist>
<listitem><para><literal>PACK_SHRINK</literal>: Space is contracted to the child widget size. The widget will take up just-enough space and never expand.</para></listitem>
<listitem><para><literal>PACK_EXPAND_PADDING</literal>: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't change - there will be empty space between the widgets instead. </para></listitem>
<listitem><para><literal>PACK_EXPAND_WIDGET</literal>: Extra space is taken up by increasing the child widget size, without changing the amount of space between widgets.</para></listitem>
</itemizedlist>
</para>

<para>
The <literal>padding</literal> argument specifies the width of an extra border area to leave around the
packed widget.
</para>

<para>Instead of the <literal>pack_start()</literal> and <literal>pack_end()</literal> methods, you might prefer to use the STL-style API, available via the <literal>children</literal> method. See the <link linkend="sec-stl-style">STL-style APIs</link> section for more details.</para>

<para><ulink url="&url_refdocs_base_gtk;Box.html">Reference</ulink></para>

</sect4>

<sect4><title>Per-container packing options</title>
<para>
Here's the constructor for the box widgets:
<programlisting>
Gtk::Box(bool homogeneous = false, int spacing = 0);
</programlisting>
Passing <literal>true</literal> for <literal>homogeneous</literal> will cause all of the contained
widgets to be the same size.  <literal>spacing</literal> is a (minimum) number of
pixels to leave between each widget.
</para>

<para>
What's the difference between spacing (set when the box is created)
and padding (set when elements are packed)? Spacing is added between
objects, and padding is added on either side of a widget. The following
figure should make it clearer:
</para>

<figure id="figure-box_packing2">
  <title>Box Packing 2</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;box_packing2.png"/>
  </screenshot>
</figure>

</sect4>
</sect3>

<sect3>
<title>Example</title>
<para>
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.</para>

<para><ulink url="&url_examples_base;box">Source Code</ulink></para>
</sect3>

</sect2>

<sect2 id="sec-ButtonBoxes">
<title>ButtonBoxes </title>

<para>
Button boxes are a convenient way to quickly arrange a group of
buttons. They come in both horizontal (<literal>Gtk::HButtonBox</literal>) and
vertical (<literal>Gtk::VButtonBox</literal>) flavours. They are exactly
alike, except in name and orientation.
</para>

<para>
ButtonBoxes help to make applications appear consistent because they use standard settings, such as inter-button spacing and packing.
</para>

<para>
Buttons are added to a <literal>ButtonBox</literal> with the <literal>add()</literal> method.
</para>

<para>
Button boxes support several layout styles.  The style can be retrieved
and changed using <literal>get_layout()</literal> and <literal>set_layout()</literal>.
</para>

<para><ulink url="&url_refdocs_base_gtk;ButtonBox.html">Reference</ulink></para>

<sect3>
<title>Example</title>

<figure id="figure-buttonbox">
  <title>ButtonBox</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;buttonbox.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;buttonbox">Source Code</ulink></para>

</sect3>

</sect2>

<sect2>
<title>Table</title>

<para>
Tables allows us to place widgets in a grid.
</para>

<sect3><title>Constructor</title>
<para>
The grid's dimensions need to be specified in the constructor:
<programlisting>
Gtk::Table(int rows = 1, int columns = 1, bool homogeneous = false);
</programlisting>
</para>

<para>
The first argument is the number of rows to make in the table, while
the second, obviously, is the number of columns.  If <literal>homogeneous</literal>
is <literal>true</literal>, the table cells will all be the same size
(the size of the largest widget in the table).
</para>

<para>
The rows and columns are indexed starting at 0.  If you specify
<literal>rows</literal> = 2 and <literal>columns</literal> = 2, the layout would look something
like this:
</para>

<para>
<programlisting>
 0          1          2
0+----------+----------+
 |          |          |
1+----------+----------+
 |          |          |
2+----------+----------+
</programlisting>
</para>

<para>
Note that the coordinate system starts in the upper left hand corner.
</para>
</sect3>

<sect3><title>Adding widgets</title>
<para>
To place a widget into a box, use the following method:
<programlisting>
void Gtk::Table::attach(Gtk::Widget&amp; child,
                        guint left_attach, guint right_attach,
                        guint top_attach, guint bottom_attach,
                        guint xoptions = Gtk::FILL | Gtk::EXPAND,
                        guint yoptions = Gtk::FILL | Gtk::EXPAND,
                        guint xpadding = 0, guint ypadding = 0);
</programlisting>
</para>
<para>				
The first argument is the widget you wish to place in the table.
</para>

<para>
The <literal>left&lowbar;attach</literal> and <literal>right&lowbar;attach</literal> arguments specify where to
place the widget, and how many boxes to use.  For example, if you want
a button in the lower-right cell of a 2 x 2 table, and want it to occupy
that cell <emphasis>only</emphasis>, then <literal>left&lowbar;attach</literal> would be 1,
<literal>right&lowbar;attach</literal> 2, <literal>top&lowbar;attach</literal> 1, and <literal>bottom&lowbar;attach</literal> 2.  If,
on the other hand, you wanted a widget to take up the entire top row
of our 2 x 2 table, you'd set <literal>left&lowbar;attach</literal> = 0, <literal>right&lowbar;attach</literal> =
2, <literal>top&lowbar;attach</literal> = 0, and <literal>bottom&lowbar;attach</literal> = 1.
</para>

<para>
<literal>xoptions</literal> and <literal>yoptions</literal> are used to specify packing options
and may be bitwise ORed together to allow multiple options.
These options are:
</para>

<para>
<variablelist>

<varlistentry>
<term><literal>Gtk::FILL</literal></term>
<listitem>
<para>
If the table box is larger than the widget, and
<literal>Gtk::FILL</literal> is specified, the widget will expand to use all the room available.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>Gtk::SHRINK</literal></term>
<listitem>
<para>
If the table widget is allocated less
space than it requested (because the user resized the window),
then the widgets will normally just disappear off the bottom of the
window. If <literal>Gtk::SHRINK</literal> is specified, the widgets
will shrink with the table.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>Gtk::EXPAND</literal></term>
<listitem>
<para>This will cause the table to expand to use up anyremaining space in the window.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
The padding arguments work just as they do for <literal>pack_start()</literal>.
</para>
</sect3>

<sect3><title>Other methods</title>

<para>
<literal>set&lowbar;row&lowbar;spacing()</literal> and
<literal>set&lowbar;col&lowbar;spacing()</literal> set the spacing between the rows at
the specified row or column. Note that for columns, the space goes to the right of the column, and for rows, the space goes below the row.
</para>

<para>
You can also set a consistent spacing for all rows and/or columns with <literal>set_row_spacings()</literal> and <literal>set_col_spacings()</literal>. Note that with these calls, the last row and last column do not get
any spacing.
</para>

<para><ulink url="&url_refdocs_base_gtk;Table.html">Reference</ulink></para>

</sect3>

<sect3><title>Example</title>
<para>
In the following example, we make a window with three buttons in a 2 x 2
table.  The first two buttons will be placed in the upper row.  A
third button is placed in the lower row, spanning both columns.
</para>

<figure id="figure-table">
  <title>Table</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;table.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;table">Source Code</ulink></para>

</sect3>

</sect2>

<sect2 id="sec-Notebook">
<title>Notebook</title>

<para>
A <literal>Notebook</literal> has a set of stacked <literal>pages</literal>, each of which contains widgets.  Labelled <literal>tabs</literal> allow the user to
select the pages.  <literal>Notebooks</literal> allow several sets of widgets to be placed in a small space, by only showing one page at a time. For instance, they are often used in preferences dialogs.
</para>

<para>Use the <literal>append_page()</literal>, <literal>prepend_page()</literal> and <literal>insert_page()</literal> methods to add tabbed pages to the <literal>Notebook</literal>, supplying the child widget and the name for the tab.</para>

<para>To discover the currently visible page, use the <literal>get_current_page()</literal> method. This returns the page number, and then calling <literal>get_nth_page()</literal> with that number will give you a pointer to the actual child widget.</para>

<para>To programmatically change the selected page, use the <literal>set_page()</literal> method.</para>

<para>There is also an  <link linkend="sec-Notebook-STL-style">STL-style API</link> which you might find more obvious.</para>

<para><ulink url="&url_refdocs_base_gtk;Notebook.html">Reference</ulink></para>

<sect3><title>Example</title>

<figure id="figure-notebook">
  <title>Notebook</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;notebook.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;notebook/">Source Code</ulink></para>

</sect3>

<sect3 id="sec-Notebook-STL-style">
<title>STL-style API</title>
<para>
The <literal>Gtk::Notebook</literal> widget has an STL-style API, available via the <literal>pages()</literal> method,  which you might prefer to use to add and access pages. See the <link linkend="sec-stl-style">STL-style APIs</link> section for generic information.</para>

<para><ulink url="&url_refdocs_base_gtk;Notebook__Helpers_1_1PageList.html">PageList Reference</ulink></para>

<para>
To insert pages into a notebook, use the <literal>TabElem</literal> helper class, like so:
<programlisting>
m_Notebook.pages().push_back( Gtk::Notebook_Helpers::TabElem(m_ChildWidget, "tab 1") );
</programlisting>
</para>

<para><ulink url="&url_refdocs_base_gtk;Notebook__Helpers_1_1TabElem.html">TabElem Reference</ulink>. TODO: Correct URL.</para>

<para>To access an existing child widget, you can call <literal>get_child()</literal> on one of the <literal>Page</literal> elements of the <literal>PageList</literal>:
<programlisting>
Gtk::Widget* pWidget = m_Notebook.pages()[2].get_child();
</programlisting>
</para>

</sect3>


</sect2>



</sect1>


</chapter>

<chapter id="sec-chapter-treeview">

<title>The TreeView widget</title>
<para>
The Gtk::TreeView widget can contain lists or trees of data, in
columns.
</para>

<sect1>
<title>The Model</title>
<para>
Each Gtk::TreeView has an associated Gtk::TreeModel, which contains the data displayed by the TreeView. Each Gtk::TreeModel can be used by more than one Gtk::TreeView. For
instance, this allows
the same underlying data to be displayed and edited in 2 different
ways at the same time. Or the 2 Views might display different columns from the
same Model data, in the same way that 2 SQL queries (or "views") might
show different fields from the same database table.
</para>
<para>
Although you can theoretically implement your own Model, you will
normally use either the ListStore or TreeStore model classes.</para>

<para><ulink url="&url_refdocs_base_gtk;TreeModel.html">Reference</ulink></para>

<sect2>
<title>ListStore, for rows</title>
<para>
The ListStore contains simple rows of data, and each row has no
children.
</para>

<figure id="figure-treeview-liststore-model">
  <title>TreeView - ListStore</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_list.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_refdocs_base_gtk;ListStore.html">Reference</ulink></para>

</sect2>

<sect2>
<title>TreeStore, for a hierarchy</title>
<para>
The TreeStore contains rows of data, and each row may have child
rows.
</para>

<figure id="figure-treeview-treestore-model">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_tree.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_refdocs_base_gtk;TreeStore.html">Reference</ulink></para>

</sect2>

<sect2>
<title>Model Columns</title>
<para>
The TreeModel::ColumnRecord class is used to keep track of the columns and
their data types. You add TreeModelColumn instances to the
ColumnRecord and then use those TreeModelColumns when getting and
setting the data in model rows. You will probably find it convenient
to derive a new TreeModel::ColumnRecord which has your TreeModelColumn
instances as member data.
</para>

<para>
<programlisting>
class ModelColumns : public Gtk::TreeModel::ColumnRecord
{
public:

  ModelColumns()
    { add(m_col_text); add(m_col_number); }

  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  Gtk::TreeModelColumn&lt;int&gt; m_col_number;
};

ModelColumns m_Columns;
</programlisting>
</para>

<para>
You specify the ColumnRecord when creating the Model, like so:
<programlisting>
Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore = Gtk::ListStore::create(m_Columns);
</programlisting>
</para>
</sect2>

<sect2>
<title>Adding Rows</title>
<para>
Add rows to the model with the <literal>append()</literal>, <literal>prepend()</literal>, or <literal>insert()</literal> methods.
<programlisting>
Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();
</programlisting>
</para>
<para>You can dereference the iterator to get the Row:
<programlisting>
Gtk::TreeModel::Row row = *iter;
</programlisting>
</para>
<sect3><title>Adding child rows</title>
<para>
<literal>Gtk::TreeStore</literal> models can have child items. Add them with the <literal>append()</literal>, <literal>prepend()</literal>, or <literal>insert()</literal> methods, like so:
<programlisting>
Gtk::TreeModel::iterator iter_child = m_refListStore-&gt;append(row.children());
</programlisting>
</para>
</sect3>

</sect2>

<sect2>
<title>Setting values</title>
<para>
You can use the operator[] override to set the data for a
particular column in the row, specifying the TreeModelColumn used to
create the model.
<programlisting>
row[m_Columns.m_col_text] = "sometext";
</programlisting>
</para>
</sect2>

<sect2>
<title>Getting values</title>
<para>
You can use the operator[] override to get the data in a particular
column in a row, specifiying the TreeModelColumn used to create the model.
<programlisting>
Glib::ustring strText = row[m_Columns.m_col_text];
int number = row[m_Columns.m_col_number];
</programlisting>
</para>
<para>
The compiler will complain if you use an inappropriate type. For
instance, this would generate a compiler error:
<programlisting>
int number = row[m_Columns.m_col_text]; //compiler error - no conversion from
ustring to int.
</programlisting>
</para>
</sect2>

<sect2>
<title>&quot;Hidden&quot; Columns</title>
<para>
You might want to associate extra data with each row. If so, just add
it as a Model column, but don't add it to the View.
</para>
</sect2>

</sect1>

<sect1 id="sec-treeview">
<title>The View</title>
<para>The View is the actual widget (Gtk::TreeView) that displays the model (Gtk::TreeModel) data and allows the user to interact with it. The View can show all of the model's columns, or just some, and it can show them in various ways. 
</para>

<para><ulink url="&url_refdocs_base_gtk;TreeView.html">Reference</ulink></para>

<sect2 id="sec-using_a_model">
<title>Using a Model</title>
<para>
You can specify a Gtk::TreeModel when constructing the Gtk::TreeView,
or you can use the set_model() method, like so:
<programlisting>
m_TreeView.set_model(m_refListStore);
</programlisting>
</para>
</sect2>

<sect2>
<title>Adding View Columns</title>
<para>
You can use the append_column() method to  tell the View that it should display certain Model columns,
in a certain order, with a certain column title.
<programlisting>
  m_TreeView.append_column("Messages", m_Columns.m_col_text);
</programlisting>
</para>
<para>
When using this simple append_column() override, the TreeView will
display the model data with an appropriate CellRenderer. For instance,
strings and numbers are shown in a simple Gtk::Entry widget, and booleans are
shown in a Gtk::CheckButton. This is usually what you need.
For other column types you must either connect a callback that converts
your type into a string representation, with
TreeViewColumn::set_cell_data_func(), or derive a custom CellRenderer.
Note that (unsigned) short is not supported by default - You could use
(unsigned) int or (unsigned) long as the column type instead.
</para>
</sect2>

<sect2>
<title>More than one Model Column per View Column</title>
<para>
To render more than one model column in a view column, you need to
create the TreeView::Column widget manually, and use pack_start() to
add the model columns to it.</para>
<para>Then use append_column() to add the view Column to the
View. Notice that Gtk::View::append_column() is overridden to accept
either a prebuilt Gtk::View::Column widget, or just the
TreeModelColumn from which it generates an appropriate
Gtk::View::Column widget.
</para>
<para>
Here is some example code from
demos/gtk-demo/example_stockbrowser.cc, which has a pixbuf icon and a
text name in the same column:
<programlisting>
Gtk::TreeView::Column* pColumn = Gtk::manage( new Gtk::TreeView::Column("Symbol") ); 

// m_columns.icon and m_columns.symbol are columns in the model.
// pColumn is the column in the TreeView:
pColumn-&gt;pack_start(m_columns.icon, false); //false = don't expand.
pColumn-&gt;pack_start(m_columns.symbol);

m_TreeView.append_column(*pColumn);
</programlisting>
</para>
</sect2>

<sect2>
<title>Specifying CellRenderer details</title>
<para>
The default CellRenderers and their default behaviour will normally
suffice, but you might occasionally need finer control. For instance,
this example code from <literal>demos/gtk-demo/example_treestore.cc</literal>, manually
constructs a Gtk::CellRenderer widget and instructs it to render the
data from various model columns through various aspects of its
appearance.
<programlisting>
Gtk::CellRendererToggle* pRenderer = Gtk::manage( new Gtk::CellRendererToggle() );
int cols_count = m_TreeView.append_column("Alex", *pRenderer);
Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);
if(pColumn)
{
  pColumn-&gt;add_attribute(pRenderer-&gt;property_active(), m_columns.alex);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);
</programlisting>
</para>

<para>
You can also connect to CellRenderer signals to detect user
actions. For instance:
<programlisting>
Gtk::CellRendererToggle* pRenderer = Gtk::manage( new Gtk::CellRendererToggle() );
pRenderer-&gt;signal_toggled().connect(
  sigc::bind( sigc::mem_fun(*this, &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)
);
</programlisting>
</para>
</sect2>

<sect2>
<title>Editable Cells</title>

<sect3>
<title>Automatically-stored editable cells.</title>
<para>
Cells in a TreeView can be edited in-place by the user. To allow this,
use the Gtk::TreeView <emphasis>insert_column_editable()</emphasis> and
<emphasis>append_column_editable()</emphasis> methods instead of
insert_column() and append_column(). When these cells are edited the
new values will be stored immediately in the Model. Note that these
methods are templates which can only be instantiated for simple column
types such as Glib::ustring, int, and long.
</para>
</sect3>

<sect3>
<title>Implementing custom logic for editable cells.</title>
<para>
However, you might not want the new values to be stored
immediately. For instance, maybe you want to restrict the input to
certain characters or ranges of values.
</para>
<para>
To achieve this, you should use the normal Gtk::TreeView
<emphasis>insert_column()</emphasis> and
<emphasis>append_column()</emphasis> methods, then use
<emphasis>get_column_cell_renderer()</emphasis> to get the
Gtk::CellRenderer used by that column.</para>
<para>You must set the cell's <emphasis>editable</emphasis> property to true, like so:
<programlisting>
cell.property_editable() = true;
</programlisting>
You should then cast that Gtk::CellRenderer* to the specific
CellRenderer that you expect, and then connect to the appropriate
"edited" signal. For instance, connect to
<emphasis>Gtk::CellRendererText::signal_edited()</emphasis>, or
<emphasis>Gtk::CellRendererToggle::signal_toggled()</emphasis>. If the
column contains more than one CellRenderer then you will need to use
<emphasis>Gtk::TreeView::get_column()</emphasis> and then call
<emphasis>get_cell_renderers()</emphasis> on that view Column.
</para>
<para>
In your signal handler, you should examine the new value and then
store it in the Model if that is appropriate for your application.
</para>
</sect3>

</sect2>


</sect1>

<sect1 id="sec-iterating_over_model_rows">
<title>Iterating over Model Rows</title>
<para>
Gtk::TreeModel provides an STL-style container of its children, via
the children() method. You can use the familiar begin() and end()
methods iterator incrementing, like so:
<programlisting>
typedef Gtk::TreeModel::Children type_children; //minimise code length.
type_children children = refModel-&gt;children();
for(type_children::iterator iter = children.begin(); iter != children.end(); ++iter)
{
  Gtk::TreeModel::Row row = *iter;
  //Do something with the row - see above for set/get.
}
</programlisting>
</para>

<sect2>
<title>Row children</title>
<para>
When using a Gtk::TreeStore, the rows can have child rows, which can
have their own children in turn. Use Gtk::TreeModel::Row::children()
to get the STL-style container of child Rows:
<programlisting>
Gtk::TreeModel::Children children = row.children();
</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-treeview_selection">
<title>The Selection</title>
<para>
To find out what rows the user has selected, get the
Gtk::TreeView::Selection object from the TreeView, like so:
<programlisting>
Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =
m_TreeView.get_selection();
</programlisting>
</para>

<sect2>
<title>Single or multiple selection</title>
<para>
By default, only single rows can be selected, but you can allow
multiple selection by setting the mode, like so:
<programlisting>
refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);
</programlisting>
</para>
</sect2>

<sect2>
<title>The selected rows</title>
<para>
For single-selection, you can just call get_selected(), like so:
<programlisting>
TreeModel::iterator iter = refTreeSelection-&gt;get_selected();
if(iter) //If anything is selected
{
  TreeModel::Row row = *iter;
  //Do something with the row.
}
</programlisting>
</para>

<para>
For multiple-selection, you need to define a callback, and give it to
selected_foreach(), selected_foreach_path(), or selected_foreach_iter(), like so:
<programlisting>
refTreeSelection-&gt;selected_foreach_iter( 
    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );

...

void TheClass::selected_row_callback(const Gtk::TreeModel::iterator&amp; iter)
{
  TreeModel::Row row = *iter;
  //Do something with the row.
}
</programlisting>
</para>

</sect2>

<sect2>
<title>The "changed" signal</title>
<para>
To respond to the user clicking on a row or range of rows, connect to the signal
  like so:
<programlisting>
refTreeSelection-&gt;signal_changed().connect(
  sigc::mem_fun(*this, &amp;Example_StockBrowser::on_selection_changed)
);
</programlisting>
</para>
</sect2>

<sect2>
<title>Preventing row selection</title>
<para>Maybe the user should not be able to select every item in your list or tree. For instance, in the gtk-demo, you can select a demo to see the source code, but it doesn't make any sense to select a demo category.</para>
<para>To control which rows can be selected, use the <literal>set_select_function()</literal> method, providing a <literal>sigc::slot</literal> callback. For instance:
<programlisting>
m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this, &amp;DemoWindow::select_function) );
</programlisting>
and then
<programlisting>
bool DemoWindow::select_function(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
                                 const Gtk::TreeModel::Path&amp; path, bool)
{
  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);
  return iter-&gt;children().empty(); // only allow leaf nodes to be selected
}
</programlisting>
</para>
</sect2>

<sect2>
<title>Changing the selection</title>
<para>
To change the selection, specify a Gtk::TreeModel::iterator or
Gtk::TreeModel::Row, like so:
<programlisting>
Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.
if(row)
  refTreeSelection-&gt;select(row);
</programlisting>
or
<programlisting>
Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()
if(iter)
  refTreeSelection-&gt;select(iter);
</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-treeview-draganddrop">
<title>Drag and Drop</title>
<para><literal>Gtk::TreeView</literal> already implments simple drag-and-drop when used with the <literal>Gtk::ListStore</literal> or <literal>Gtk::TreeStore</literal> models. If necessary, it also allows you to implement more complex behaviour when items are dragged and dropped, using the normal <link linkend="sec-draganddrop">Drag and Drop</link> API.
</para>

<sect2>
<title>Reorderable rows</title>
<para>If you call <literal>Gtk::TreeView::set_reorderable()</literal> then your TreeView's items can be moved within the treeview itself. This is demonstrated in the <literal>TreeStore</literal> example.</para>
<para>However, this does not allow you any control of which items can be dragged, and where they can be dropped. If you need that extra control then you might create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the <literal>Gtk::TreeDragSource::row_draggable()</literal> and <literal>Gdk::TreeDragDest::row_drop_possible()</literal> virtual methods. You can examine the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow dragging or dropping by return <literal>true</literal> or <literal>false</literal>.</para>
<para>This is demonstrated in the drag_and_drop example.</para>
</sect2>

</sect1>

<sect1 id="sec-treeview-contextmenu">
<title>Popup Context Menu</title>
<para>Lots of people need to implement right-click context menus for <literal>TreeView</literal>'s so we will explain how to do that  here to save you some time. Apart from one or two points, it's  much the same as a normal context menu, as described in the <link linkend="sec-menus-popup">menus chapter</link>.
</para>

<sect2>
<title>Handling <literal>button_press_event</literal></title>
<para>To detect a click of the right mouse button, you need to handle the <literal>button_press_event</literal> signal, and check exactly which button was pressed. Because the <literal>TreeView</literal> normally handles this signal completely, you need to either override the default signal handler in a derived <literal>TreeView</literal> class, or use <literal>connect_nofify()</literal> insted of <literal>connect()</literal>. You probably also want to call the default handler before doing anything else, so that the right-click will cause the row to be selected first.</para>
<para>This is demonstrated in the Popup Custom Menu example.</para>
</sect2>

</sect1>

<sect1 id="sec-treeview_examples"><title>Examples</title>

<sect2><title>ListStore</title>
<para>This example has a <literal>Gtk::TreeView</literal> widget, with a <literal>Gtk::ListStore</literal> model.</para>


<figure id="figure-treeview-liststore">
  <title>TreeView - ListStore</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_list.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;treeview/list/">Source Code</ulink></para>

</sect2>

<sect2><title>TreeStore</title>

<para>This example is very similar to the ListStore example, but uses a <literal>Gtk::TreeStore</literal> model instead, and adds children to the rows.</para>

<figure id="figure-treeview-treestore">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_tree.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;treeview/tree/">Source Code</ulink></para>

</sect2>

<sect2 id="sec-editable_cells_example"><title>Editable Cells</title>

<para>
This example is identical to the ListStore example, but it uses <literal>TreeView::append_column_editable()</literal> instead of <literal>TreeView::append_column()</literal>.
</para>

<figure id="figure-treeview-editablecells">
  <title>TreeView - Editable Cells</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_editablecells.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;treeview/editable_cells/">Source Code</ulink></para>

</sect2>

<sect2><title>Drag and Drop</title>

<para>
This example is much like the TreeStore example, but has 2 extra columns to indicate whether the row can be dragged, and whether it can receive drag-and-dropped rows. It uses a derived <literal>Gtk::TreeStore</literal> which overrides the virtual functions as described in the <link linkend="sec-treeview-draganddrop">TreeView Drag and Drop</link> section..
</para>

<figure id="figure-treeview-draganddrop">
  <title>TreeView - Drag And Drop</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_draganddrop.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;treeview/drag_and_drop/">Source Code</ulink></para>

</sect2>

<sect2><title>Popup Context Menu</title>

<para>
This example is much like the ListStore example, but derives a custom TreeView in order to override the <literal>button_press_event</literal>, and also to encapsulate the tree model code in our derived class. See the <link linkend="sec-treeview-contextmenu">TreeView Popup Context Menu</link> section.
</para>

<figure id="figure-treeview-popup">
  <title>TreeView - Popup Context Menu</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;treeview_popup.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;treeview/popup/">Source Code</ulink></para>

</sect2>


</sect1>

</chapter>


<chapter id="sec-chapter-textview">
<title>TextView</title>
<para>The <literal>TextView</literal> widget can be used to display and edit large amounts of formatted text. Like the <literal>TreeView</literal>, it has a model/view design. In this case the <literal>TextBuffer</literal> is the model.</para>

<sect1>
<title>The Buffer</title>
<para><literal>Gtk::TextBuffer</literal> is a model containing the data for the <literal>Gtk::TextView</literal>, like the <literal>Gtk::TreeModel</literal> used by <literal>Gtk::TreeView</literal>. This allows two or more <literal>Gtk::TextView</literal>s to share the same <literal>TextBuffer</literal>, and allows those TextBuffers to be displayed slightly differently. Or you could maintain several <literal>Gtk::TextBuffer</literal>s and choose to display each one at different times in the same <literal>Gtk::TextView</literal> widget.
</para>
<para>The <literal>TextView</literal> creates its own default <literal>TextBuffer</literal>, which you can access via the <literal>get_buffer()</literal> method.
</para>

<para><ulink url="&url_refdocs_base_gtk;TextBuffer.html">Reference</ulink></para>

<sect2>
<title>Iterators</title>
<para>
</para>
</sect2> 

<sect2>
<title>Tags and Formatting</title>

<sect3>
<title>Tags</title>
<para>
To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:
<programlisting>
Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch = Gtk::TextBuffer::Tag::create();
refTagMatch-&gt;property_background() = "orange";
</programlisting>
You can specify a name for the <literal>Tag</literal> when using the <literal>create()</literal> method, but it is not necessary.
</para>

<para>
The <literal>Tag</literal> class has many other properties.
</para>

<para><ulink url="&url_refdocs_base_gtk;TextTag.html">Reference</ulink></para>

</sect3>

<sect3>
<title>TagTable</title>

<para>Each <literal>Gtk::TextBuffer</literal> uses a <literal>Gtk::TextBuffer::TagTable</literal>, which contains the <literal>Tag</literal>s for that buffer. 2 or more <literal>TextBuffer</literal>s may share the same <literal>TagTable</literal>. When you create <literal>Tags</literal> you should add them to the <literal>TagTable</literal>. For instance:
<programlisting>
Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable = Gtk::TextBuffer::TagTable::create();
refTagTable-&gt;add(refTagMatch);
Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer = Gtk::TextBuffer::create(refTagTable); //Hopefully a future version of gtkmm will have a set_tag_table() method, for use after creation of the buffer.
</programlisting>
</para>

<para>You can also use <literal>get_tag_table</literal> to get, and maybe modify, the <literal>TextBuffer</literal>'s default <literal>TagTable</literal> instead of creating one explicitly.</para>

<para><ulink url="&url_refdocs_base_gtk;TextTagTable.html">Reference</ulink></para>

</sect3>

<sect3>
<title>Applying Tags</title>
<para>If you have created a <literal>Tag</literal> and added it to the <literal>TagTable</literal>, you may apply that tag to part of the <literal>TextBuffer</literal> so that some of the text is displayed with that formatting. You define the start and end of the range of text by specifying <literal>Gtk::TextBuffer::iterator</literal>s. For instance:
<programlisting>
refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);
</programlisting>
Or you could specify the tag when first inserting the text:
refBuffer-&gt;insert_with_tag(iter, "Some text", refTagMatch);
</para>

<para>You can apply more than one <literal>Tag</literal> to the same text, by using <literal>apply_tag()</literal> more than once, or by using <literal>insert_with_tags()</literal>. The <literal>Tags</literal> might specify different values for the same properties, but you can resolve these conflicts by using <literal>Tag::set_priority()</literal>.
</para>

</sect3>
</sect2>

<sect2>
<title>Marks</title>
<para>
<literal>TextBuffer</literal> <literal>iterators</literal> are generally invalidated when the text changes, but you can use a <literal>Gtk::TextBuffer::Mark</literal> to remember a position in these situations. For instance,
<programlisting>
Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark = refBuffer-&gt;create_mark(iter);
</programlisting>
</para>

<para>You can then use the <literal>get_iter()</literal> method later to create an iterator for the <literal>Mark</literal>'s new position.</para>

<para>There are two built-in <literal>Mark</literal>s - <literal>insert</literal> and <literal>select_bound</literal>, which you can access with <literal>TextBuffer</literal>'s <literal>get_insert()</literal> and <literal>get_selection_bound()</literal> methods.
</para>

<para><ulink url="&url_refdocs_base_gtk;TextMark.html">Reference</ulink></para>

</sect2>

<sect2>
<title>The View</title>
<para>
As mentioned above, each <literal>TextView</literal> has a <literal>TextBuffer</literal>, and one or more <literal>TextView</literal> can share the same <literal>TextBuffer</literal>. 
</para>

<para>Like the <literal>TreeView</literal>, you should probably put your <literal>TextView</literal> inside a <literal>ScrolledWindow</literal> to allow the user to see and move around the whole text area with scrollbars.</para>

<para><ulink url="&url_refdocs_base_gtk;TextView.html">Reference</ulink></para>

<sect3>
<title>Default formatting</title>
<para>
<literal>TextView</literal> has various methods which allow you to change the presentation of the buffer for this particular view. Some of these may be overridden by the <literal>Gtk::TextTag</literal>s in the buffer, if they specify the same things. For instance, set_left_margin(), set_right_margin(), set_indent(), etc.
</para>
</sect3>

<sect3>
<title>Scrolling</title>
<para>
<literal>Gtk::TextView</literal> has various scroll_to_*() methods. These allow you to ensure that a particular part of the text buffer is visible. For instance, your application's Find feature might use <literal>Gtk::TextView::scroll_to_iter()</literal> to show the found text.
</para>
</sect3>

</sect2>


</sect1>

<sect1 id="sec-widgets_and_childanchors">
<title>Widgets and ChildAnchors</title>
<para>
You can embed widgets, such as <literal>Gtk::Button</literal>s, in the text. Each such child widget needs a <literal>ChildAnchor</literal>. ChildAnchors are associated with <literal>iterators</literal>. For instance, to create a child anchor at a particular position, use <literal>Gtk::TextBuffer::create_child_anchor()</literal>:
<programlisting>
Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor = refBuffer-&gt;create_child_anchor(iter);
</programlisting>
</para>

<para>
Then, to add a widget at that position, use <literal>Gtk::TextView::add_child_at_anchor</literal>:
<programlisting>
m_TextView.add_child_at_anchor(m_Button, refAnchor);
</programlisting>

</para>

<para><ulink url="&url_refdocs_base_gtk;TextChildAnchor.html">Reference</ulink></para>

</sect1>

<sect1 id="sec-examples"><title>Examples</title>

<sect2><title>Simple Example</title>

<figure id="figure-textview">
  <title>TextView</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;textview.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;textview/">Source Code</ulink></para>

</sect2>

</sect1>

</chapter>

<chapter id="sec-MenusAndToolbars">
<title>Menus and Toolbars</title>

<para>There are specific APIs for Menus and toolbars, but you should usually deal with them together, using the <literal>UIManager</literal> to define <literal>actions</literal> which you can then arrange in menu and toolbars. In this way you can handle activation of
the action instead of responding to the menu and toolbar items separately. And you can enable or disable both the menu and toolbar item via the action.</para>
<para>This involves the use of the <literal>Gtk::ActionGroup</literal>, <literal>Gtk::Action</literal>, and <literal>UIManager</literal> classes, all of which should be instantiated via their <literal>create()</literal> methods, which return <literal>RefPtr</literal>s.</para>

<sect1>
<title>Actions</title>
<para>First create the <literal>Action</literal>s and add them to an <literal>ActionGroup</literal>, with <literal>ActionGroup::add()</literal>.</para>

<para>The arguments to <literal>Action::create()</literal>
specify the action's name and how it will appear in menus and toolbars. Use stock items where possible so that you don't need to
specify the label, accelerator, icon, and tooltips, and so you can use pre-existing translations.</para>
<para>You can also specify a signal handler when calling <literal>ActionGroup::add()</literal>. This signal handler will be called when the action is
activated via either a menu item or a toolbar button.</para>
<para>Note that you must specify actions for sub menus as well as menu items.</para>

<para>For instance:
<programlisting>
m_refActionGroup = Gtk::ActionGroup::create();

m_refActionGroup-&gt;add( Gtk::Action::create(&quot;MenuFile&quot;, &quot;_File&quot;) );
m_refActionGroup-&gt;add( Gtk::Action::create(&quot;New&quot;, Gtk::Stock::NEW),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );
m_refActionGroup-&gt;add( Gtk::Action::create(&quot;ExportData&quot;, &quot;Export Data&quot;),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );
m_refActionGroup-&gt;add( Gtk::Action::create(&quot;Quit&quot;, Gtk::Stock::QUIT),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );   
</programlisting>
</para>
</sect1>


<sect1>
<title>UIManager</title>
<para>Next you should create a UIManager and add the ActionGroup to the UIManager with <literal>insert_action_group()</literal> At this point is also a good idea to tell the parent window to respond to the specified keyboard shortcuts, by using <literal>add_accel_group</literal>.</para>  

<para>For instance,
<programlisting>
Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager = Gtk::UIManager::create();
m_refUIManager-&gt;insert_action_group(m_refActionGroup);
add_accel_group(m_refUIManager-&gt;get_accel_group());
</programlisting>
</para>
<para>Then, you can define the actual visible layout of the menus and toolbars, and add the UI layout to the UIManager. This &quot;ui string&quot; uses an XML format, in which you should mention the names of the actions that you have already created. For instance:
<programlisting>
    Glib::ustring ui_info =
        &quot;&lt;ui&gt;&quot;
        &quot;  &lt;menubar name='MenuBar'&gt;&quot;
        &quot;    &lt;menu action='MenuFile'&gt;&quot;
        &quot;      &lt;menuitem action='New'/&gt;&quot;
        &quot;      &lt;menuitem action='Open'/&gt;&quot;
        &quot;      &lt;separator/&gt;&quot;
        &quot;      &lt;menuitem action='Quit'/&gt;&quot;
        &quot;    &lt;/menu&gt;&quot;
        &quot;    &lt;menu action='MenuEdit'&gt;&quot;
        &quot;      &lt;menuitem action='Cut'/&gt;&quot;
        &quot;      &lt;menuitem action='Copy'/&gt;&quot;
        &quot;      &lt;menuitem action='Paste'/&gt;&quot;
        &quot;    &lt;/menu&gt;&quot;
        &quot;  &lt;/menubar&gt;&quot;
        &quot;  &lt;toolbar  name='ToolBar'&gt;&quot;
        &quot;    &lt;toolitem action='Open'/&gt;&quot;
        &quot;    &lt;toolitem action='Quit'/&gt;&quot;
        &quot;  &lt;/toolbar&gt;&quot;
        &quot;&lt;/ui&gt;&quot;;

    m_refUIManager-&gt;&gt;add_ui_from_string(ui_info);
</programlisting>
</para>
<para>To instantiate a Gtk::MenuBar or Gtk::Toolbar which you can actually show, you should use the <literal>UIManager::get_widget()</literal> method, and then add the widget to a container. For instance:
<programlisting>
Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(&quot;/MenuBar&quot;);
pBox-&gt;add(*pMenuBard, Gtk::PACK_SHRINK);
</programlisting> 
</para>

</sect1>


<sect1 id="sec-menus-popup"><title>Popup Menus</title>
<para>
Menus are normally just added to a window, but they can also be displayed temporarily as the result of a mouse button click. For instance, a context menu might be diplayed when the user clicks their right mouse button.</para>

<para>The UI layout for a popup menu should use the <literal>popup</literal> node. For instance:
<programlisting>
    Glib::ustring ui_info = 
        &quot;&lt;ui&gt;&quot;
        &quot;  &lt;popup name='PopupMenu'&gt;&quot;
        &quot;    &lt;menuitem action='ContextEdit'/&gt;&quot;
        &quot;    &lt;menuitem action='ContextProcess'/&gt;&quot;
        &quot;    &lt;menuitem action='ContextRemove'/&gt;&quot;
        &quot;  &lt;/popup&gt;&quot;
        &quot;&lt;/ui&quot;;
        
    m_refUIManager-&gt;add_ui_from_string(ui_info);
</programlisting>
</para>

<para>To show the popup menu, use <literal>Gtk::Menu</literal>'s <literal>popup()</literal> method, providing the button identifier and the time of activation, as provided by the <literal>button_press_event</literal> signal, which you will need to handle anyway. For instance:
<programlisting>
bool ExampleWindow::on_button_press_event(GdkEventButton* event)
{
  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )
  {
    m_Menu_Popup->popup(event-&gt;button, event-&gt;time);
    return true; //It has been handled.
  }
  else
    return false;
}
</programlisting>
</para>

</sect1>

<sect1><title>Examples</title>

<sect2><title>Main Menu example</title>

<figure id="figure-menus-mainmenu">
  <title>Main Menu</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;main_menu.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;menus/main_menu/">Source Code</ulink></para>

</sect2>

<sect2><title>Popup Menu example</title>

<figure id="figure-menus-popup">
  <title>Popup Menu</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;menu_popup.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;menus/popup/">Source Code</ulink></para>

</sect2>

</sect1>

</chapter>

<chapter id="sec-Adjustment">
<title>Adjustments </title>

<para>
gtkmm has various widgets that can be visually adjusted using the mouse or the keyboard, such as the Range widgets (described
in the <link linkend="sec-Range-Widgets">Range Widgets</link> section).
There are also a few widgets that display some adjustable
part of a larger area, such as the
Viewport widget. These widgets have <literal>Gtk::Adjustment</literal> objects that express this common part of their API.
</para>

<para>
So that applications can react to changes, for instance when a user moves a scrollbar, <literal>Gtk::Adjustment</literal> has a
<literal>changed</literal> signal. You can then use the <literal>get_changed()</literal> method to discover the new value.
</para>

<sect1>
<title>Creating an Adjustment</title>

<para>
The <literal>Gtk::Adjustment</literal> constructor is as follows:
</para>

<para>
<programlisting>
Gtk::Adjustment(float value,
                float lower,
                float upper,
                float step_increment = 1,
                float page_increment = 10,
                float page_size = 0);
</programlisting>
</para>

<para>
The <literal>value</literal> argument is the initial value of the adjustment, usually corresponding to the topmost or leftmost position
of an adjustable widget. The <literal>lower</literal> and <literal>upper</literal> arguments specifies the possible range of values which the adjustment can hold. The <literal>step&lowbar;increment</literal> argument
specifies the smaller of the two increments by which the user can
change the value, while the <literal>page&lowbar;increment</literal> is the larger one.
The <literal>page&lowbar;size</literal> argument usually corresponds somehow to the visible
area of a panning widget. The <literal>upper</literal> argument is used to represent
the bottom most or right most coordinate in a panning widget's
child.
TODO: Investigate the upper argument properly. There was some unclear stuff about it not always being the upper value.
</para>

</sect1>

<sect1 id="sec-adjustments_the_easy_way">
<title>Using Adjustments the Easy Way</title>

<para>
The adjustable widgets can be roughly divided into those which use and
require specific units for these values, and those which treat them as
arbitrary numbers.
</para>
<para>
The group which treats the values as arbitrary numbers includes the Range widgets (Scrollbars and Scales, the
Progressbar widget, and the SpinButton widget). These widgets  are typically "adjusted" directly by the user
with the mouse or keyboard. They will treat the <literal>lower</literal> and
<literal>upper</literal> values of an adjustment as a range within which the user
can manipulate the adjustment's <literal>value</literal>. By default, they will only
modify the <literal>value</literal> of an adjustment.
</para>

<para>
The other group includes the <literal>Viewport</literal> widget and the <literal>ScrolledWindow</literal> widget. All of these
widgets use pixel values for their adjustments. These are also typically adjusted indirectly using scrollbars.
While all widgets which use adjustments can either create their own
adjustments or use ones you supply, you'll generally want to let this
particular category of widgets create its own adjustments.
</para>

<para>
TODO: Text widget is deprecated: Look at GTK+ tutorial for up-to-date example.
If you share an adjustment object between a Scrollbar and a Text
widget, manipulating the scrollbar will automagically adjust the Text
widget. You can set it up like this:
<programlisting>
  // creates its own adjustments
  Gtk::Text text(0, 0);
  // uses the newly-created adjustment for the scrollbar as well
  Gtk::VScrollbar vscrollbar (*(text.get_vadjustment()));
</programlisting>
</para>

</sect1>

<sect1 id="sec-adjustment_internals">
<title>Adjustment Internals</title>

<para>
OK, you say, that's nice, but what if I want to create my own handlers
to respond when the user adjusts a Range widget or a SpinButton.
To access the value of a <literal>Gtk::Adjustment</literal>, you can use the
<literal>get_value()</literal> and <literal>set_value()</literal> methods:
</para>

<para>
As mentioned earlier, <literal>Gtk::Adjustment</literal> can emit signals.
This is, of course, how updates happen automagically when you share an
Adjustment object between a Scrollbar and another adjustable widget;
all adjustable widgets connect signal handlers to their adjustment's
<literal>value&lowbar;changed</literal> signal, as can your program.
</para>

<para>
So, for example, if you have a Scale
widget, and you want to change the rotation of a picture whenever its
value changes, you would create a signal handler like this:
<programlisting>
void cb_rotate_picture (Gtk::Widget *picture)
{
  picture-&#62;set_rotation (adj-&#62;value);
...
</programlisting>
and connect it to the scale widget's adjustment like this:
<programlisting>
adj.value_changed.connect(sigc::bind&#60;Widget*&#62;(sigc::mem_fun(*this, &amp;cb_rotate_picture), picture));
</programlisting>
</para>

<para>
What if a widget reconfigures the <literal>upper</literal> or <literal>lower</literal>
fields of its Adjustment, such as when a user adds more text to a text
widget?  In this case, it emits the <literal>changed</literal> signal.
</para>

<para>
Range widgets typically connect a handler to this signal, which
changes their appearance to reflect the change - for example, the size
of the slider in a scrollbar will grow or shrink in inverse proportion
to the difference between the <literal>lower</literal> and <literal>upper</literal> values of its
adjustment.
</para>

<para>
You probably won't ever need to attach a handler to this signal,
unless you're writing a new type of range widget.
<programlisting>
adjustment-&#62;changed();
</programlisting>
</para>

</sect1>

</chapter>

<chapter id="widgets_without_xwindows">
<title>Widgets Without X-Windows</title>

<para>
Some Widgets do not have an associated X-Window, so they
therefore do not receive X events. This means that the signals described in the  <link linkend="sec-xeventsignals">X event signals</link> section will not be emitted. If you want to capture events for these widgets you can use a special container called
<literal>Gtk::EventBox</literal>, which is described in the <link linkend="sec-EventBox">EventBox</link> section.
</para>

<para>
Here is a list of some of these Widgets:
<programlisting>
Gtk::Alignment
Gtk::Arrow
Gtk::Bin
Gtk::Box
Gtk::Image
Gtk::Item
Gtk::Label
Gtk::Pixmap
Gtk::ScrolledWindow
Gtk::Separator
Gtk::Table
Gtk::AspectFrame
Gtk::Frame
Gtk::VBox
Gtk::HBox
Gtk::VSeparator
Gtk::HSeparator
</programlisting>
</para>

<para>
These widgets are mainly used for decoration or layout, so you won't often need
to capture events on them. They are intended to have no X-Window in order to improve performance.
</para>

<sect1 id="sec-EventBox">
<title>EventBox</title>

<para>
TODO: Why don't they have X Windows - explain clipping.
Some gtkmm widgets don't have associated X windows; they draw on
their parents' windows.  Because of this, they cannot receive events.
Also, if they are incorrectly sized, they don't clip, so you can get
messy overwriting etc. If you require more from these widgets, the
EventBox is for you.  Although the name EventBox emphasises the
event-handling method, the widget can also be used for clipping
(and more; see the example below).
</para>

<para>
The constructor for <literal>Gtk::EventBox</literal> is:
</para>

<para>



<programlisting>
Gtk::EventBox();
</programlisting>



</para>

<para>
A child widget can be added to the EventBox using:
</para>

<para>
<programlisting>
event_box.add(child_widget);
</programlisting>
</para>

<para><ulink url="&url_refdocs_base_gtk;EventBox.html">Reference</ulink></para>

<sect2>
<title>Example</title>
<para>
The following example demonstrates both uses of an <literal>EventBox</literal> - a label
is created that is clipped to a small box, and set up so that a
mouse-click on the label causes the program to exit. Resizing the
window reveals varying amounts of the label.
</para>

<figure id="figure-eventbox">
  <title>EventBox</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;eventbox.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;eventbox">Source Code</ulink></para>
</sect2>

</sect1>

</chapter>

<chapter id="sec-Dialogs">
<title>Dialogs</title>

<para>
Dialogs are used as secondary windows, to provide specific information or to ask questions. <literal>Gtk::Dialog</literal> windows contain a few pre-packed widgets to ensure consistency, and a <literal>run()</literal> method which blocks until the user dismisses the dialog.</para>

<para>
There are several derived dialog classes which you might find useful. For instance, you will probably use <literal>Gtk::MessageDialog</literal> for most simple notifications. But at other times you might need to derive your own dialog class to provide more complex functionality.
</para>

<para>
To pack widgets into a custom dialog, you should pack them into the <literal>Gtk::VBox</literal>, available via <literal>get_vbox()</literal>. To just add a button to the bottom of the dialog, you could use the <literal>add_button()</literal> method.
</para>

<para>The <literal>run()</literal> method returns an <literal>int</literal>. This may be a value from the <literal>Gtk::ResponseType</literal> if the user closed the button by clicking a standard button, or it could be the custom response value that you specified when using <literal>add_button()</literal>.</para>

<para><ulink url="&url_refdocs_base_gtk;Dialog.html">Reference</ulink></para>

<sect1 id="sec-dialogs_messagedialog"><title>MessageDialog</title>
<para>
This is a convenience class, used to create simple, standard message dialogs, with a message, an icon, and buttons for user response. You can specify the type of message and the text in the constructor, as well as specifying standard buttons via the  <literal>Gtk::ButtonsType</literal> enum.
</para>

<para><ulink url="&url_refdocs_base_gtk;MessageDialog.html">Reference</ulink></para>

<sect2>
<title>Example</title>

<figure id="figure-dialogs-messagedialog">
  <title>MessageDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;dialogs_messagedialog.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;dialogs/messagedialog">Source Code</ulink></para>
</sect2>

</sect1>

<sect1 id="sec-dialogs_filechooserdialog"><title>FileChooserDialog</title>
<para>
This dialog is suitable for use with &quot;Open&quot; or &quot;Save&quot; menu items. 
</para>
<para>
Most useful member methods for this class are actually in the Gtk::FileChooser base class.
</para>

<para><ulink url="&url_refdocs_base_gtk;FileChooserDialog.html">Reference</ulink></para>

<sect2>
<title>Example</title>

<figure id="figure-dialogs-filechooser">
  <title>FileChooser</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;dialogs_filechooser.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;dialogs/filechooserdialog">Source Code</ulink></para>
</sect2>
</sect1>

<sect1 id="sec-color_selection_dialog"><title>ColorSelectionDialog</title>
<para>
This dialog allows the user to choose a color.
</para>

<para><ulink url="&url_refdocs_base_gtk;ColorSelectionDialog.html">Reference</ulink></para>

<sect2>
<title>Example</title>

<figure id="figure-dialogs-colorselectiondialog">
  <title>ColorSelectionDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;dialogs_colorselectiondialog.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;dialogs/colorselectiondialog">Source Code</ulink></para>
</sect2>

</sect1>

<sect1 id="sec-font_selection_dialog"><title>FontSelectionDialog</title>
<para>
This dialog allows the user to choose a font.
</para>

<para><ulink url="&url_refdocs_base_gtk;FontSelectionDialog.html">Reference</ulink></para>

<sect2>
<title>Example</title>

<figure id="figure-dialogs-fontselectiondialog">
  <title>FontSelectionDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;dialogs_fontselectiondialog.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;dialogs/fontselectiondialog">Source Code</ulink></para>
</sect2>

</sect1>


</chapter>

<chapter id="sec-drawingarea">
  <title>The Drawing Area Widget</title>
  <para>
    The DrawingArea widget is a blank X window that gives you the freedom to create any graphic you desire. Along with that
    freedom comes the responsibility to handle expose events on the widget. When a widget is first shown, or when it is covered and then
    uncovered again it needs to redraw itself. Most widgets have code to do this, but the DrawingArea  does not, allowing you to write an expose event signal handler to determine how the contents of the widget will be drawn.
  </para>
  <para>
    There are a number of methods to help you draw various objects into the widget, such as pixels, lines, rectangles, elipses,
    polygons, images, and text. We'll take each one in turn and give an example of its use.
  </para>
  <sect1>
    <title>Graphics Contexts</title>
    <para>
      Before getting into the actual drawing routines, some background information about graphics contexts is
      needed. Graphics contexts are a server-side resource. They contain information that describes how drawing is to be
      done. This provides for fewer arguments to the drawing methods, and less communication between the client and the
      server. The following example shows  how to set up a graphics context with a foreground color of red for drawing.
    </para>
    <programlisting>
Gdk::GC some_gc;
some_gc.create(get_window());
Gdk::Color some_color;
Gdk::Colormap some_colormap(Gdk::Colormap::get_system());
some_color.set_red(65535);
some_color.set_green(0);
some_color.set_blue(0);
some_colormap.alloc(some_color);
some_gc.set_foreground(some_color);
    </programlisting>
    <para>
      The first two lines create the graphics context and assign it to the appropriate widget. The <function>get_window()
      </function> method
      is a part of the <classname>Gtk::Widget</classname> class, so if you put this code into a derived widget's implementation then
      you can call it just
      as it is, otherwise you'd use <function>some_widget.get_window()</function>.
    </para>
    <para>
      The next two lines create the <classname>Gdk::Color</classname> and <classname>Gdk::Colormap</classname>. After setting
      the color values you then need to allocate the color. The system figures out what to do in this case. The colormap
      contains information about how colors can be displayed on your screen, and is able to allocate the requested color. For
      example, on a display of only 256 colors the exact color requested may not be available, so the closest color to the one requested will be used instead. The final line sets the color as the foreground color.
    </para>
    <para>
      There are a number of attributes that can be set for a graphics context. There's the foreground and background color.
      When drawing lines, you can set the thickness of the line with <function>set_line_width()</function>. Whether a solid
      or dashed line is drawn can be set with <function>set_line_style()</function>. The size and proportions of the dashes are set with <function>set_dashes</function>. How two lines join together, whether round or pointed or
      beveled off, is set with <function>set_join_style()</function>.
      Other things that can be set within a graphics context include font style, stippling and tiling for the filling of
      solid polygons.
    </para>
  </sect1>
  <sect1 id="sec-drawing_pixels">
    <title>Drawing Pixels</title>
    <para>
      You can draw individual pixels with the two methods <function>Gdk::Drawable::draw_point()</function> and <function>
      Gdk::Drawable::draw_points()</function>. All drawing methods take a <classname>Gdk::GC</classname> as their first
      argument, except where noted. The other two arguments to <function>draw_point()</function> are the x coordinate
      (horizontal position relative to the left edge of the widget, starting at 0), and the y coordinate (vertical position
      relative to the top of the widget, starting at 0). <function>draw_points()</function> takes two arguments, the
      <classname>Gdk::GC</classname> and a collection of <classname>Gdk::Points</classname>. The second argument can be any kind
      of standard container, such as a <classname>std::vector&lt;Gdk::Point&gt;</classname>. So for example
      <function>draw_point()</function> could be used like this:
    </para>
    <programlisting>get_window()-&gt;draw_point(some_gc, 20, 20);</programlisting>
    <para>
      But <function>draw_points()</function> is a bit more complicated and might be used like this:
    </para>
    <programlisting>
std::vector&lt;Gdk::Point&gt; points_array;
points_array.push_back(Gdk::Point(10, 10));
points_array.push_back(Gdk::Point(20, 20));
draw_points(some_gc, points_array); //One way to draw the two points.

    </programlisting>
  </sect1>
  <sect1 id="sec-drawing_lines">
    <title>Drawing Lines</title>
    <sect2><title>Example</title>
    <para>
    Drawing lines is more interesting than just points, so here is a complete program:
    </para>


    <figure id="figure-drawingarea-lines">
      <title>Drawing Area - Lines</title>
      <screenshot>
        <graphic format="PNG" fileref="&url_figures_base;drawingarea_lines.png"/>
      </screenshot>
    </figure>

    <para><ulink url="&url_examples_base;drawingarea">Source Code</ulink></para>

    <para>
      This program contains two classes. The first is a subclass of <classname>Gtk::DrawingArea</classname> and contains an
      <function>on_expose_event</function> member function. This method is called whenever the image in the drawing
      area needs to be redrawn.
      The four additional arguments to <function>draw_line()</function> (besides the graphics context as the first) are the
      coordinates for the start and end of the line.
    </para>
    <para>
      The <classname>TestWindow</classname> class contains a drawing area. When it is created, it creates a drawing area
      of 50 pixels across by 50 pixels tall. If the window is resized, the graphic drawn is kept in the top left corner of the
      larger window. The drawing area is created with a default grey background.
    </para>
    </sect2>
  </sect1>
  <sect1 id="sec-drawing_rectangles_and_polygons">
    <title>Drawing Rectangles and Polygons</title>
    <para>
      The <function>draw_rectangle()</function> method draws rectangles and squares. The second argument determines whether
      the rectangle is filled. Give a non-zero value to have the rectangle filled. The third and fourth arguments
      specify the x and y coordiates of the upper-left corner of the rectangle, respectively. The last two arguments specify
      the width and height (in pixels) of the rectangle.
    </para>
    <para>
      Because of the way X handles drawing, an outline rectangle is one pixel taller and wider than a filled rectangle. If
      you want a rectangle with an outline of one color and a fill of another color, you need to draw the filled rectangle first.
      Otherwise the filled rectangle will obscure the top and left edges of the outline rectangle. You may need to subtract one pixel from the  width and height of the outline rectangle to get the size you expect.
    </para>
    <para>
      The <function>draw_polygon()</function> method takes a <classname>Glib::ArrayHandle&lt;Gdk::Point&gt;</classname>, which is
      another way of saying a standard container of <classname>Gdk::Point</classname>, just like we saw in
      <function>draw_points()</function> above.
      The first argument is the <classname>Gdk::GC</classname> and the second argument determines if the polygon is a filled one or
      an outline, just like for the <function>draw_rectangle()</function>. The polygon's shape is taken by drawing a line from the
      first point to the second, and so on to the last point in the list, and from there a line is drawn back to the first point.
      This of course implies that you do not need to repeat the first point as the last point.
    </para>
  </sect1>
  <sect1 id="sec-drawing_ellipses_and_arcs">
    <title>Drawing Ellipses and Arcs</title>
    <para>
      The <function>draw_arc()</function> has a lot of parameters. The second one is again for the choice of filled or unfilled arc.
      The next two arguments are the x and y coordinates of the upper left corner of the circle. Imagine a
      rectangle surrounding the circle, and just touching it at the top, bottom, and sides. The upper left corner of this box
      is the point specified by the x and y coordinates. The width and height of this box are the next two arguments. A wide
      box will make a wide elliptical shape.
    </para>
    <para>
      The final two arguments define the starting and ending angle, in case you do not want to make a complete circle. The
      angle is measured in 1/64th of a degree, starts at the right, and runs counter-clockwise.
    </para>
  </sect1>
  <sect1 id="sec-drawing_text">
    <title>Drawing Text</title>
    <para>
      Text is drawn via Pango Layouts. The easiest way to create a <classname>Pango::Layout</classname> is to use
      <function>create_pango_layout</function>. Once created, the layout can be manipulated in various ways, including changing
      the text, font, etc. Finally, the layout can be rendered using the <function>draw_layout</function> method of <classname>Gdk::Drawable</classname>, which takes the usual <classname>Gdk::GC</classname>, an x-position, a y-position and the layout itself.
    </para>

    <sect2><title>Example</title>
    <para>
      Here's a sample program using all of the drawing methods shown so far:
    </para>

    <figure id="figure-drawingarea-text">
      <title>Drawing Area - Text</title>
      <screenshot>
        <graphic format="PNG" fileref="&url_figures_base;drawingarea_text.png"/>
      </screenshot>
    </figure>

    <para><ulink url="&url_examples_base;drawingarea_text">Source Code</ulink></para>

    <para>
      The structure of the program is the same as the first one, except that this one includes examples of the drawing elements
      discussed up to now.
    </para>
    </sect2>
  </sect1>
  <sect1 id="sec-draw_images">
    <title>Draw Images</title>
    <para>
      There are a couple of drawing methods for putting image data into a drawing area. <function>draw_pixmap()</function> can
      copy the contents of a <classname>Gdk::Drawable</classname> (the window of a drawing area is one) into the drawing area.
      There is also <function>draw_bitmap()</function> for drawing a two-color image into the drawing area, and
      <function>draw_image()</function> for drawing an image with more than two colors.
    </para>
    <para>
      For all of these methods, the first argument is the <classname>Gdk::GC</classname>. The second argument is the
      object of the appropriate type to copy in: <classname>Gdk::Drawable</classname>, <classname>Gdk::Bitmap</classname>,
      <classname>Gdk::Image</classname>. The next two arguments are the x and y points in the image to begin copying from. Then
      come the x and y points in the drawing area to copy to. The final two arguments are the width and height of the area to
      copy.
    </para>
    <para>
      There is also a method for drawing from a <classname>Gdk::Pixbuf</classname>. A <classname>Gdk::Pixbuf</classname>
      buffer is a useful wrapper around a collection of pixels, which can be read from files, and manipulated in various ways.
    </para>
    <para>
      Probably the most common way of creating <classname>Gdk::Pixbuf</classname>s is to use
      <function>Gdk::Pixbuf::create_from_file()</function>, which can read an image file, such as a png file into a pixbuf ready
      for rendering.
    </para>
    <para>
      The <classname>Gdk::Pixbuf</classname> can be rendered with <function>render_to_drawable</function>, which takes quite a few parameters. The <function>render_to_drawable</function> is a member of <classname>Gdk::Pixbuf</classname> rather than <classname>Gdk::Drawable</classname>, which is unlike the <function>draw_*</function> functions described earlier. As such, its first parameter is the drawable to render to. The second parameter is still the <classname>Gdk::GC</classname>. The next two parameters are the point in the pixbuf to start drawing from. This is followed by the point in the drawable to draw it at, and by the width and height to actually draw (which may not be the whole image, especially if you're only responding to an expose event for part of the window). Finally, there are the dithering parameters. If you use Gdk::RGB_DITHER_NONE as the dither type, then the dither offset parameters can both be 0.
    </para>
    <para>
      Here is a small bit of code to tie it all together: (Note that usually you wouldn't load the image every time in the expose event handler! It's just shown here to keep it all together)
    </para>
    <programlisting>
bool myarea::on_expose_event(GdkEventExpose* ev)
{
  Glib::RefPtr&lt;Gdk::PixBuf&gt; image = Gdk::PixBuf::create_from_file("myimage.png");
  image-&gt;render_to_drawable(get_window(), get_style()-&gt;get_black_gc(),
    0, 0, 100, 80, image-&gt;get_width(), image-&gt;get_height(), // draw the whole image (from 0,0 to the full width,height) at 100,80 in the window
    Gdk::RGB_DITHER_NONE, 0, 0);
  return true;
}

    </programlisting>
  </sect1>
</chapter>

<chapter id="sec-draganddrop">
<title>Drag and Drop</title>
<para>Gtk::Widget has several methods and signals which are prefixed with "drag_". These are used for Drag and Drop.</para>
<sect1>
<title>Sources and Destinations</title>
<para>Things are dragged from <literal>sources</literal> to be dropped on <literal>destinations</literal>. Each source and destination has infomation about the data formats that it can send or receive, provided by <literal>Gtk::TargetEntry</literal> items. A drop destination will only accept a dragged item if they both share a compatible Gtk::TargetEntry item. Appropriate signals will then be emitted, telling the signal handlers which Gtk::TargetEntry was used.</para>
<para>Gtk::TargetEntry objects contain this information&colon;
<itemizedlist>
<listitem><para>target: A name, such as &quot;STRING&quot;</para></listitem>
<listitem><para>info: An identifier which will be sent to your signals to tell you which TargetEntry was used.</para></listitem>
<listitem><para>flags: TODO</para></listitem>
</itemizedlist>
</para>

</sect1>

<sect1 id="sec-drag_and_drop_methods">
<title>Methods</title>
<para>Widgets can be identified as sources or destinations using these Gtk::Widget methods:</para>
<para>
<programlisting>
void drag_source_set(const ArrayHandle_TargetEntry&amp; targets, GdkModifierType start_button_mask, GdkDragAction actions);
</programlisting>

<itemizedlist>
<listitem><para><literal>targets</literal> is a container of Gtk&colon;&colon;TargetEntry (std&colon;&colon;list&lt;Gtk&colon;&colon;TargetEntry&gt; or std::vector&lt;Gtk&colon;&colon;TargetEntry&gt;, for instance) elements.</para></listitem>
<listitem><para><literal>start_button_mask</literal> is an ORed combination of values, which specify which modifier key or mouse button must be pressed to start the drag.</para></listitem>
<listitem><para><literal>actions</literal> is an ORed combination of values, which specified which Drag and Drop operations will be possible from this source - for instance, copy, move, or link. The user can choose between the actions by using modifier keys, such as <literal>Shift</literal> to change from <literal>copy</literal> to <literal>move</literal>, and this will be shown by a different cursor.</para></listitem>
</itemizedlist>
</para>

<para>
<programlisting>
void drag_dest_set(const ArrayHandle_TargetEntry&amp; targets, GtkDestDefaults flags, GdkDragAction actions);
</programlisting>

<itemizedlist>
<listitem><para><literal>flags</literal> is an ORed combination of values which indicates how the widget will respond visually to Drag and Drop items.</para></listitem>
<listitem><para><literal>actions</literal> indicates the Drag and Drop actions which this destination can receive - see the description above.</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1 id="sec-drag_and_drop_signals">
<title>Signals</title>
<para>When a drop destination has accepted a dragged item, certain signals will be emitted, depending on what action has been selected. For instance, the user might have held down the <literal>Shift</literal> key to specify a <literal>move</literal> rather than a <literal>copy</literal>. Remember that the user can only select the actions which you have specified in your calls to <literal>drag_dest_set()</literal> and <literal>drag_source_set()</literal>.</para>

<sect2 id="sec-drag_and_drop_copy">
<title>Copy</title>
<para>
The source widget will emit these signals, in this order:
<itemizedlist>
<listitem><para><literal>drag_begin</literal>: Provides DragContext.</para></listitem>
<listitem><para><literal>drag_motion</literal>: Provides DragContext and coordinates. You can call the drag_status() method of the DragContext to indicate which target will be accepted.</para></listitem>
<listitem><para><literal>drag_get</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>GtkSelectionData</literal> structure, in which you should put the requested data.</para></listitem>
<listitem><para><literal>drag_drop</literal>: Provides DragContext and coordinates.</para></listitem>
<listitem><para><literal>drag_end</literal>: Provides DragContext.</para></listitem>
</itemizedlist>
</para>
<para>
The destination widget will emit this signal, after the source destination has emitted the <literal>drag_get</literal> signal:
<itemizedlist>
<listitem><para><literal>drag_data_received</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>GtkSelectionData</literal> structure which contains the dropped data. You should  call the <literal>drag_finish()</literal> method of the <literal>DragContext</literal> to indicate whether the operation was successful.</para></listitem>
</itemizedlist>
</para>

</sect2>

<sect2>
<title>Move</title>
<para>During a <literal>move</literal>, the source widget will also emit this signal:
<itemizedlist>
<listitem><para><literal>drag_delete</literal>: Gives the source the opportunity to delete the original data if that's appropriate.</para></listitem>
</itemizedlist>
</para>
</sect2>

<sect2>
<title>Link</title>
<para>TODO: Find an example or documentation.</para>
</sect2>
</sect1>

<sect1 id="sec-dragcontext">
<title>DragContext</title>
<para>
The drag and drop signals provide a DragContext, which contains some information about the drag and drop operation and can be used to influence the process. For instance, you can discover the source widget, or  change the drag and drop icon, by using the <literal>set_icon()</literal> methods. More importantly, you should call the <literal>drag_finish()</literal> method from your <literal>drag_data_received</literal> signal handler to indicate whether the drop was successful.
</para>
</sect1>

<sect1 id="sec-drag_and_drop_example">
<title>Example</title>
<para>Here is a very simple example, demonstrating a drag and drop <literal>Copy</literal> operation:</para>

<figure id="figure-drag_and_drop">
  <title>Drag and Drop</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;drag_and_drop.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;drag_and_drop">Source Code</ulink></para>

<para>
There is a more complex example in examples/dnd.
</para>

</sect1>

</chapter>

<chapter id="sec-clipboard">
<title>The Clipboard</title>
<para>Simple text copy-paste functionality is provided for free by widgets such as Gtk::Entry and Gtk::TextView, but you might need special code to deal with your own data formats. For instance, a drawing program would need special code to allow copy and paste within a view, or between documents.</para>

<para><literal>Gtk::Clipboard</literal> is a singleton. You can get the one and only instance with <literal>Gtk::Clipboard::get()</literal>.</para>

<para>So your application doesn't need to wait for clipboard operations, particularly between the time when the user chooses Copy and then later chooses Paste, most <literal>Gtk::Clipboard</literal> methods take <literal>sigc::slot</literal>s which specify callback methods. When <literal>Gtk::Clipboard</literal> is ready, it will call these methods, either providing the requested data, or asking for data.  
</para>

<para><ulink url="&url_refdocs_base_gtk;Clipboard.html">Reference</ulink></para>

<sect1>
<title>Targets</title>
<para>
Different applications contain different types of data, and they might make that data available in
a variety of formats. gtkmm calls these data types <literal>target</literal>s.</para> 

<para>
For instance, gedit can supply and receive the <literal>&quot;UTF8_STRING&quot;</literal> target, so you can paste data into gedit from any application that supplies that target. Or two different image editing applications might supply and receive a variety of image formats as targets. As long as one application can receive one of the targets that the other supplies then you will be able to copy data from one to the other.
</para>

<para>A target can be in a variety of binary formats. This chapter, and the examples, assume that the data is 8-bit text. This would allow us to use an XML format for the clipboard data. However this would probably not be appropriate for binary data such as images. <literal>Gtk::Clipboard</literal> provides overloads that allow you to specify the format in more detail if necessary.</para>

<para>The <link linkend="sec-draganddrop">Drag and Drop</link> API uses the same mechanism. You should probably use the same data targets and formats for both Clipboard and Drag and Drap operations.</para>
</sect1>

<sect1 id="sec-drag_and_drop_copy">
<title>Copy</title>
<para>
When the user asks to copy some data, you should tell the clipboard what targets are available, and provide the callback methods that it can use to get the data. At this point you should store a copy of the data, to be provided when the clipboard calls your callback method in repsonse to a paste.
</para>
<para>For instance,
<programlisting>  
Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();

//Targets:
std::list&lt;Gtk::TargetEntry&gt; listTargets;
listTargets.push_back( Gtk::TargetEntry(&quot;example_custom_target&quot;) ); 
listTargets.push_back( Gtk::TargetEntry("UTF8_STRING") ); 
  
refClipboard-&gt;set( listTargets, 
  sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get), 
  sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );
</programlisting>
</para>

<para>Your callback will then provide the store data when the user chooses to paste the data. For instance:
<programlisting>
void ExampleWindow::on_clipboard_get(Gtk::SelectionData&amp; selection_data, guint info)
{ 
  const Glib::ustring target = selection_data.get_target(); 
  
  if(target == &quot;example_custom_target&quot;)
    selection_data.set(&quot;example_custom_target&quot;, m_ClipboardStore);
}
</programlisting>
The <literal>ideal</literal> example below can supply more than one clipboard target.
</para>

<para>The clear callback allows you to free the memory used by your stored data when the clipboard replaces its data with something else.
</para>

</sect1>

<sect1 id="sec-drag_and_drop_paste">
<title>Paste</title>
<para>
When the user asks to paste data from the clipboard, you should request a specific format and provide a callback method which will be called with the actual data. For instance: 
<programlisting>
refClipboard-&gt;request_contents(&quot;example_custom_target&quot;,  sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );
</programlisting>
</para>

<para>Here is an example callback method:
<programlisting>
void ExampleWindow::on_clipboard_received(const Gtk::SelectionData&amp; selection_data)
{
  Glib::ustring clipboard_data = selection_data.get_data_as_text();
  //Do something with the pasted data.
}  
</programlisting>
</para>

<sect2>
<title>Discovering the available targets</title>
<para>To find out what targets are currently available on the clipboard for pasting, call the <literal>request_methods()</literal> method, specifying a method to be called with the information. For instance:
<programlisting>
refClipboard-&gt;request_targets( sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received_targets) );
</programlisting>
</para>

<para>
In your callback, compare the list of available targets with those that your application supports for pasting. You could enable or disable a Paste menu item, depending on whether pasting is currently possible. For instance:
<programlisting>
void ExampleWindow::on_clipboard_received_targets(const Gtk::SelectionData&amp; selection_data)
{
  bool bPasteIsPossible = false;

  //Get the list of available clipboard targets:
  typedef std::list&lt;Glib::ustring&gt; type_listTargets;
  type_listTargets targets = selection_data.get_targets();

  //and see if one is suitable:
  for(type_listTargets::const_iterator iter = targets.begin(); iter != targets.end(); ++iter)
  {
    if(*iter == &quot;example_custom_target&quot;)
      bPasteIsPossible = true;
  }

  //Do something, depending on whether bPasteIsPossible is true.                                          
}
</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-clipboard_examples"><title>Examples</title>

<sect2 id="sec-clipboard-example-simple"><title>Simple</title>
<para>This example allows copy and pasting of application-specific data, using the standard text target. Although this is simple, it's not ideal because
it does not identify the clipboard data as being of a particular type.</para>

<figure id="figure-clipboard-simple">
  <title>Clipboard - Simple</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;clipboard_simple.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;clipboard/simple/">Source Code</ulink></para>

</sect2>

<sect2 id="sec-clipboard-example-ideal"><title>Ideal</title>
<para>This is like the simple example, but it 
<orderedlist>
<listitem><simpara>Defines a custom clipboard target, though the format of that target is still text.</simpara></listitem>
<listitem><simpara>It supports pasting of 2 targets - both the custom one and a text one that creates an arbitrary text representation of the custom data.</simpara></listitem>
<listitem><simpara>It uses request_targets() and disables the Paste button if it can't use anything on
the clipboard</simpara></listitem>
</orderedlist>
</para>

<figure id="figure-clipboard-ideal">
  <title>Clipboard - Ideal</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;clipboard_ideal.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;clipboard/ideal/">Source Code</ulink></para>

</sect2>

</sect1>


</chapter>

<chapter id="sec-timeouts">
<title>Timeouts, I/O and Idle Functions </title>

<sect1>
<title>Timeouts</title>

<para>
You may be wondering how to make gtkmm do useful work while it's
idling along (well, sleeping actually) in <literal>Gtk::Main::run()</literal>.  Happily,
you have several options. Using the following methods you can create
a timeout method that will be called every few milliseconds.
</para>

<para>
<programlisting>
sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot, unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
</programlisting>
</para>

<para>
The first argument is a slot you wish to have called when the timeout
occurs. The second argument is the number of milliseconds between
calls to that method. You receive a <literal>sigc::connection</literal> object that can be
used to deactivate the connection.
</para>

<para>

<programlisting>
my_connection.disconnect();
</programlisting>
</para>

<para>
to destroy the connection. Another way of destroying the connection
is your signal handler. It has to be of the type
<literal>sigc::slot&lt;bool&gt;</literal>. As you see from the definition your
signal handler has to return a value of the type <literal>bool</literal>.  A
definition of a sample method might look like this:
</para>

<para>



<programlisting>
bool MyCallback() { std::cout &lt;&lt; "Hello World!\n" &lt;&lt; std::endl; return true; }
</programlisting>



</para>

<para>
You can stop the timeout method by returning <literal>false</literal> from
your signal handler.  Therefore, if you want your
method to be called repeatedly, it should return <literal>true</literal>.
</para>

<para>
Here's an example of this technique:
</para>

<para><ulink url="&url_examples_base;timeout/">Source Code</ulink></para>

</sect1>

<sect1 id="sec-monitoring_io">
<title>Monitoring I/O</title>

<para>
TODO: This is now in Glib, not Gdk. 

A nifty feature of GDK (one of the libraries underlying
gtkmm) is the ability to have it check for data on a file descriptor
for you.  This is especially useful for networking applications. The
following method is used to do this:
</para>

<para>
<programlisting>
sigc::connection Glib::Main::SignalInput::connect(const SlotType&amp; sd, int source,
                                    Glib::InputCondition condition);
</programlisting>
</para>

<para>
The first argument is a slot (SlotType is a typedef to a sigc::slot&lt;&gt;) you wish to have called when then the
specified event (see argument 3) occurs on the file descriptor you
specify using argument two. Argument three may be one or more
(using <literal>&verbar;</literal>) of:
</para>

<para>

<itemizedlist>
<listitem>

<para>
GDK&lowbar;INPUT&lowbar;READ - Call your method when there is data ready for
reading on your file descriptor.

</para>
</listitem>
<listitem>

<para>
GDK&lowbar;INPUT&lowbar;WRITE - Call your method when the file descriptor is
ready for writing.

</para>
</listitem>
<listitem>

<para>
GDK&lowbar;INPUT&lowbar;EXCEPTION - Call your method when an exception happened
on the file descriptor.
</para>
</listitem>

</itemizedlist>

</para>

<para>
The return value is a sigc::connection that may be used to stop monitoring
this file descriptor using its <literal>disconnect</literal> method.
The <literal>sd</literal> signal handler should be declared as follows:
</para>

<para>
<programlisting>
void input_callback(int source, GdkInputCondition condition);
</programlisting>
</para>

<para>
where <literal>source</literal> and <literal>condition</literal> are as specified above. As usual
the slot is created with <literal>sigc::mem_fun()</literal> (for a member method of an object.), or <literal>sigc::ptr_fun</literal> (for a function).
</para>

<para>
A little (and somewhat dirty) example follows.  To use
the example just execute it from a terminal; it doesn't create a
window.  It will create a pipe named <literal>testpipe</literal> in the current
directory. Then start another shell and execute <literal>cat
&#62;testpipe</literal>. The example will print each line you enter until you
type <literal>quit</literal>.
</para>

<para><ulink url="&url_examples_base;input/">Source Code</ulink></para>

</sect1>

<sect1 id="sec-idle_functions">
<title>Idle Functions</title>

<para>
If you want to specify a method that gets called when nothing else is happening, use the following:
</para>

<para>
<programlisting>
sigc::connection  Glib::Main::SignalIdle::connect(const Slot&lt;int&gt;&amp; idlefunc, int priority);
</programlisting>
</para>

<para>
This causes gtkmm to call the specified method whenever nothing else
is happening. You can add a priority (lower numbers are higher
priorities).  If you don't supply a priority value, then
Gtk::PRIORITY&lowbar;DEFAULT will be used. There are two ways to remove the
signal handler: calling <literal>disconnect</literal> on the sigc::connection object, or
returning <literal>false</literal> (or 0) in the signal handler, which should be
declared as follows:
</para>

<para>
<programlisting>
int idleFunc();
</programlisting>
</para>

<para>
Since this is very similar to the methods above this explanation should
be sufficient to understand what's going on. However, here's a little example:
</para>

<para><ulink url="&url_examples_base;idle/">Source Code</ulink></para>

<para>
This example points out the difference of idle and timeout methods a
little.  If you need methods that are called periodically, and speed
is not very important, then you want timeout methods. If
you want methods that are called as often as possible (like
calculating a fractal in background), then use idle methods.
</para>

<para>
Try executing the example and increasing the system load. The upper
progress bar will increase steadily; the lower one will slow down.
</para>

</sect1>

</chapter>

<chapter id="sec-Memory">
<title>Memory management</title>

<sect1>
<title>Widgets</title>

<sect2>
<title>Normal C++ memory management</title>

<para>
gtkmm allows the programmer to control the lifetime (that is, the construction
and destruction) of any widget in the same manner as any other C++ object.
This flexibility allows you to use <literal>new</literal> and
<literal>delete</literal> to create and destroy objects dynamically
or to use regular class members (that are destroyed automatically when the
class is destroyed) or to use local instances (that are destroyed when the
instance goes out of scope).  This flexibility is not present in some C++ GUI
toolkits, which restrict the programmer to only a subset of C++'s memory
management features.  
</para>

<para>Here are some examples of normal C++ memory management:</para>

<sect3>
<title>Class Scope widgets</title>

<para>
If a programmer does not need dynamic memory allocation, automatic widgets in class 
scope may be used.  One advantage of automatic widgets in class scope is that
memory management is grouped in one place.  The programmer does not 
risk memory leaks from failing to <literal>delete</literal> a widget.
</para>

<para>
The primary disadvantages of using class scope widgets are revealing
the class implementation rather than the class interface in the class header.  Class
scope widgets also require Automatic widgets in class scope suffer the same disadvantages as 
any other class scope automatic variable.  
</para>

<para>
<programlisting>
#include &lt;gtkmm/button.h&gt;
class Foo
{
private:
  Gtk::Button theButton;
  // will be destroyed when the Foo object is destroyed
};
</programlisting>
</para>
</sect3>

<sect3>
<title>Function scope widgets</title>

<para>
If a programmer does not need a class scope widget, a function scope widget 
may also be used.  The advantages to function scope over class scope are the 
increased data hiding and reduced dependencies.


<programlisting>
{
  Gtk::Button aButton;
  aButton.show();
  ...
  kit.run();
}
</programlisting>
</para>
</sect3>

<sect3>
<title>Dynamic allocation with new and delete</title>

<para> 
Although, in most cases, the programmer will prefer to allow containers to
automatically destroy their children using manage() (see below), the programmer is not
required to use manage(). The traditional <literal>new</literal>
and <literal>delete</literal> operators may also be used.  
</para>

<para>

<programlisting>
Gtk::Button* pButton = new Gtk::Button("Test");
	
// do something useful with pButton
	
delete pButton;
</programlisting>

Here, the programmer deletes pButton to prevent a memory leak.
</para>
</sect3>

</sect2>

<sect2>
<title>Managed Widgets</title>

<para>
Alternatively, you can let a widget's container control when the widget is
destroyed.  In most cases, you want a widget to last only as long as the
container it is in.  To delegate the management of a widget's lifetime to its
container, first create it with <literal>manage()</literal> and
pack it into its container with <literal>add()</literal>.  Now, the
widget will be destroyed whenever its container is destroyed.
</para>

<sect3>
<title>Dynamic allocation with manage() and add()</title>

<para>
gtkmm provides the manage() and add() methods to create and destroy widgets. 
Every widget except a top-level window must be added or packed into a container in 
order to be displayed.  The manage() function marks a packed widget so that when the 
widget is added to a container, the container becomes responsible for deleting the 
widget.
</para>

<para>
<programlisting>
MyWidget::MyWidget()
{
  Gtk::Button* pButton = manage(new Gtk::Button("Test"));
  add(*pButton); //add aButton to MyWidget
}
</programlisting>

Now, when MyWidget is destroyed, the button will also be deleted.  It is no
longer necessary to delete pButton to free the button's memory; its deletion
has been delegated to MyWidget.
</para>

<para>
gtkmm also provides the set&lowbar;manage() method for all widgets.
This can be used to generate the same result as manage(), but
is more tedious: 
</para>

<para>
foo.add( (w=new Gtk::Label("Hello"), w-&gt;set&lowbar;manage(), &amp;w) );
</para>

<para>
is the same as
</para>

<para>
foo.add( manage(new Gtk::Label("Hello")) );
</para>

<para>
Of course, a top level container will not be added to another container.  The
programmer is responsible for destroying the top level container using one of 
the traditional C++ techniques. For instance, your top-level Window might just be an instance in your main() function..
</para>

</sect3>
</sect2>
</sect1>

<sect1 id="sec-Memory-SharedResources">
<title>Shared resources</title>

<para>
Some objects, such as Pixmaps and Fonts, are obtained from a shared store. Therefore you cannot instantiate your own instances. These classes typically inherit from Glib::Object. Rather than requiring you to reference and unreference these objects, gtkmm uses the RefPtr&lt;&gt; smartpointer.</para>

<para>Objects such as Gdk::Bitmap can only be instantiated with a create() function. For instance,
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap = Gdk::Bitmap::create(window, data, width, height);
</programlisting>
</para>

<para>You have no way of getting a bare Gdk::Bitmap. In the example, bitmap is a smart pointer, so you can do this, much like a normal
pointer:
<programlisting>
if(bitmap)
{
  int depth = bitmap-&gt;get_depth().
}
</programlisting>
</para>

<para>
When bitmap goes out of scope an unref() will happen in the background and you
don't need to worry about it anymore. There's no new so there's no delete.
</para>
<para>
If you copy a RefPtr, for instance
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap2 = bitmap.
</programlisting>
, or if you pass it as a method argument or a return type, then RefPtr will do any necessary referencing to ensure that the instance will not be destroyed until the last RefPtr has gone out of scope.
</para>
<para>See the <link linkend="sec-appendix-refptr">appendix</link> for detailed information about RefPtr.</para>
<para>
If you wish to learn more about smartpointers, you might look in these
books:
<itemizedlist>
<listitem><para>
Bjarne Stroustrup, "The C++ Programming Language" - section 14.4.2
</para></listitem>
<listitem><para>
Nicolai M. Josuttis, "The C++ Standard Library" - section 4.2
</para></listitem>
</itemizedlist>
</para>

</sect1>

</chapter>

<chapter id="sec-libglademm">
<title>Glade and libglademm</title>
<para>
Although you can use C++ code to instantiate and arrange widgets, this
can soon become tedious and repetitive. And it requires a recompilation to show
changes. The <literal>Glade</literal> application allows you to layout widgets
on screen and then save an XML description of the arrangement. Your application can then use the <literal>libglademm</literal> API to load that XML file at runtime and obtain a pointer to specifically named widget instances. 
</para>

<para>
This has the following advantages:
<orderedlist>
<listitem><simpara>Less C++ code is required.</simpara></listitem>
<listitem><simpara>UI changes can be seen more quickly, so UIs are able to improve.</simpara></listitem>
<listitem><simpara>Designers without programming skills can create and edit UIs.</simpara></listitem>
</orderedlist>
</para>

<para>You still need C++ code to deal with User Interface changes triggered by user actions, but using <literal>libglademm</literal> for the basic widget layout allows you to focus on implementing that functionality.</para>

<sect1>
<title>Loading the .glade file</title>
<para>
<literal>Gnome::Glade::Xml</literal> must be used via a <literal>Glib::RefPtr</literal>. Like all such classes, you need to use create() method to instantiate it. 
<programlisting>
Glib::RefPtr&lt;Gnome::Glade::Xml&gt; refXml = Gnome::Glade::Xml::create(&quot;basic.glade&quot;);
</programlisting>
This will instantiate the windows defined in the .glade file, though they will not be shown immediately unless you have specified that via the Properties window in Glade. The widgets are ownedg by the <literal>Gnome::Glade::Xml</literal> instance, and will be deleted automatically when it is deleted, when the last copy of the smartpointer goes out of scope.
</para>

<para>To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance,
<programlisting>
Glib::RefPtr&lt;Gnome::Glade::Xml&gt; refXml = Gnome::Glade::Xml::create(&quot;basic.glade&quot;, &quot;treeview_products&quot;);
</programlisting>
</para>

</sect1>

<sect1 id="sec-accessing_widgets">
<title>Accessing widgets</title>

<para>
To access a widget, for instance to <literal>show()</literal> a dialog, use the <literal>get_widget()</literal> method, providing the widget's name. This name should be specified in the Glade Properties window. If the widget could not be found, or is of the wrong type, then the pointer will be set to 0.
<programlisting>
Gtk::Dialog* pDialog = 0;
refXml-&gt;get_widget(&quot;DialogBasic&quot;, pDialog);
</programlisting>
</para>

<para>libglademm checks for a null pointer, and checks that the widget is of the expected type, and will show warnings on the command line about these.</para>

<para>Remember that you are not instantiating a widget with <literal>get_widget()</literal>, you are just obtaining a pointer to one that already exists. You will always receive a pointer to the same instance when you call <literal>get_widget</literal> on the same <literal>Gnome::Glade::Xml</literal>, with the same widget name. The widgets are instantiated during <literal>Glade::Xml::create()</literal>. 
</para>

<para><literal>get_widget()</literal> returns child widgets that are manage()ed (see the <link linkend="sec-Memory">Memory Management</link> chapter), so they will be deleted when their parent container is deleted. So, if you get only a child widget from libglademm, instead of a whole window, then you must either put it in a Container or delete it.
Windows (such as Dialogs) can not be managed because they have no parent container, so you must delete them at some point.</para>

<sect2>
<title>Example</title>
<para>The <literal>basic</literal> example in the <literal>libglademm</literal> package shows how to load a Glade file at runtime and access the widgets with libglademm.
</para>
</sect2>

</sect1>


<sect1 id="sec-using_derived_widgets">
<title>Using derived widgets</title>
<para>
You can use Glade to layout your own custom widgets derived from gtkmm widget classes. This keeps your code organised and encapsulated. Of course you won't see the exact appearance and properties of your derived widget in Glade, but you can specify its location and child widgets and the properties of its gtkmm base class.
</para>

<para>Use <literal>Glade::Xml::get_widget_derived()</literal> like so: 
<programlisting>
DerivedDialog* pDialog = 0;
refXml-&gt;get_widget_derived(&quot;DialogBasic&quot;, pDialog);
</programlisting>
</para>

<para>Your derived class must have a constructor that takes a pointer to the underlying C type (there is a typedef for this), and the Gnome::Glade::Xml instance. You must call the base class's constructor in the initialization list, providing the C pointer. For instance,
<programlisting>
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gnome::Glade::Xml&gt;&amp; refGlade)
: Gtk::Dialog(cobject)
{
}
</programlisting>
</para>
 
<para>You could then encapsulate the manipulation of the child widgets in the constructor of the derived class, maybe using get_widget() or get_widget_derived() again. For instance,
<programlisting>
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gnome::Glade::Xml&gt;&amp; refGlade)
: Gtk::Dialog(cobject),
  m_refGlade(refGlade),
  m_pButton(0)
{
  //Get the Glade-instantiated Button, and connect a signal handler:
  m_refGlade-&gt;get_widget(&quot;quit_button&quot;, m_pButton);
  if(m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );
  }
}
</programlisting>
</para>

<sect2>
<title>Example</title>
<para>The <literal>derived</literal> example in the <literal>libglademm</literal> package shows how to load a Glade file at runtime and access a widgets via a derived class.
</para>
</sect2>

</sect1>

</chapter>

<chapter id="sec-internationalization">
    <title>Internationalization and Localization</title>

    <para><literal>gtkmm</literal> applications can easily support multiple languages, including non-ASCII languages such as Chinese and right-to-left languages such as Arabic. An appropriately-written gtkmm application will use the appropriate language at runtime based on the user's environment.</para>
<para>You might not anticipate the need to support additional languages, but you can never rule it out. And it's easier to develop the application properly in the first place rather than retrofitting later.</para>
<para>The process of writing source code that allows for translation is called <literal>internationalization</literal>, often abbreviated to <literal>i18n</literal>. The <literal>Localization</literal> process provides translated text for other languages, based on that source code.</para>

<sect1><title>English in the source code, translations in the .po files.</title>
<para>String literals should be typed in the source code in english as normal, but they should be surrounded by a call to the gettext() function. These strings will be extracted for translation and the translations may be used at runtime instead of the original english strings.
</para>
    
    <sect2 id="sec-i18n-gettext">
      <title>gettext</title>
      
      <para>The <application>GNU gettext</application> package allows you to mark strings in source code, extract those strings for translation, and use the translated strings in your application.</para>
	
	<para>Call
	  <literal>gettext()</literal> with the string literals that
	  should be translated. For example:

<programlisting>
window.set_title(gettext("My application"));	  
label.set_text(gettext("This is some text"));
</programlisting>
</para>

<para>Using <literal>gettext()</literal> throughout your source code can make it harder to read, so many projects, such as <literal>GNOME</literal> define the shorter <literal>_()</literal> macro that does the same thing. For instance,
<programlisting>
window.set_title(_("My application"));	  
label.set_text(_("This is some text"));
</programlisting>

</para>

      <sect3>
	<title>How gettext works</title>
	
	<para><literal>xgettext</literal> script extracts the strings and put them in a
	  <filename>mypackage.pot</filename> file. The translators of
	  your application create their translations by first copying this .pot file to <filename>languagename.po</filename> files. A locale identifies a language and an encoding for that language, including date and numerical formats. Later, when the
          text in your source code has changed, the <literal>msmerge</literal> script is used to update the
	  <filename>localename.po</filename> files from the regnerated .pot file.</para>

	<para> At install time, the <filename>.po</filename> files are
	  converted to a binary format (with the extension
	  <filename>.mo</filename>) and placed in a system-wide directory
	  for locale files.</para>

	<para>When the application runs, the
	  <application>gettext</application> library checks the
	  system-wide directory to see if there is a
	  <filename>.mo</filename> file for the user's locale environment
	  (you can set the locale with, for instance, "export LANG=de_DE.UTF-8" from a bash console). Later, when the program reaches a
	  <literal>gettext</literal> call, it looks for a translation.
	   If none is found, the original string
	  is used.</para>
      </sect3>

      <sect3>
       <title>gettext and build files</title>
         <para>To use gettext, you need to modify your application's build files, to use the gettext library, to generate the .pot file, and to install the translations from the .po files.</para>
         <para>
         <orderedlist>
         <listitem><simpara>Run <literal>getttextize --force --copy --intl</literal> - you should add this to your autogen.sh script. This creates the <literal>po</literal> and <literal>intl</literal> subdirectories, among other things.</simpara></listitem>
         <listitem><simpara>Create po/Makevars, by copying po/Makevars.template and editing it.</simpara></listitem>
         <listitem><simpara>Add AM_GNU_GETTEXT to your configure.in</simpara></listitem>
         <listitem><simpara>Define ALL_LINGUAS in your configure.in, listing the locales for which .po translations exist in your po directory.</simpara></listitem>
         <listitem><simpara>Add intl and po to the SUBDIRS in your top-level Makefile.am</simpara></listitem>
         </orderedlist>
         </para>

         <para>To add a translation for a new locale, just copy po/yourproject.pot to somelocale.po, such as de.po or hu.po. Also add the locale name to ALL_LINGUAS in your configure.in.</para>

         <para>This is demonstrated in the <literal>gtkmm_hello</literal> example package, available from the <literal>gtkmm</literal> download page.</para>
         <para>See also, the <ulink url="http://www.gnu.org/manual/gettext/html_chapter/gettext_toc.html#SEC_Contents">gettext manual</ulink>.</para>
      </sect3>

      <sect3>
        <title>GNOME's intltool</title>
           <para>Applications often use text that isn't in their source code. For instance, desktop menu details, and GUI resource files such as Glade files. But gettext() works only with C/C++ source code. Therefore, the GNOME developers created <literal>intltool</literal>. It uses gettext() but combines strings from other files into the gettext .pot/.po files. The <literal>intltool</literal> equivalent of <literal>gettextize</literal> is <literal>intltoolize</literal>. The <literal>intltool</literal> README file tells you what modifications to make to your build files.</para>
           <para>This is demonstrated in the <literal>gnomemm_hello</literal> example package, available from the <literal>gtkmm</literal> download page.</para>
      </sect3>
    </sect2>
</sect1>

<sect1 id="sec-expecting_utf8">
<title>Expecting UTF8</title>
<para>
A properly internationalized application will not make assumptions about the number of bytes in a character. That means that you shouldn't use pointer arithmetic to step through the characters in a string, and it means you shouldn't use std::string or standard C functions such as strlen() because they make the same assumption.
</para>
<para>
However, you probably already avoid bare char* arrays and pointer arithmetic by using std::string, so you just need to start using Glib::ustring instead. See the <link linkend="sec-basics-ustring">Basics</link> chapter about Glib::ustring.
</para>

<sect2><title>Glib::ustring and std::iostreams</title>
<para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para>
<para>
Unfortunately, the integration with the standard iostreams is
not completely foolproof. <literal>gtkmm</literal> converts
Glib::ustrings to a locale-specific encoding (which usually is not
UTF-8) if you output them to an <literal>ostream</literal> with
<literal>operator&lt;&lt;</literal>. Likewise, retrieving
Glib::ustrings from <literal>istream</literal> with
<literal>operator&gt;&gt;</literal> causes a conversion in the
opposite direction. But this scheme breaks down if you go through a
std::string, e.g. by inputting text from a stream to a std::string and
then implicitly converting it to a Glib::ustring. If the string
contained non-ASCII characters and the current locale is not UTF-8
encoded, the result is a corrupted Glib::ustring. You can work around
this with a manual conversion. For instance, to retrieve the
std::string from a <literal>ostringstream</literal>:
<programlisting>
std::ostringstream output;
output.imbue(std::locale("")); // use the user's locale for this stream
output &lt;&lt; percentage &lt;&lt; " % done";
label-&gt;set_text(Glib::locale_to_utf8(output.str()));
</programlisting>
</para>
</sect2>

</sect1>

    <sect1 id="sec-i18n-pitfalls">
      <title>Pitfalls</title>

      <para>There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them.</para>

      <sect2>
	<title>Same strings, different semantics</title>

	<para>Sometimes two english strings are identical but have different meanings in
different contexts, so they would probably not be identical when translated. Since the English strings are
	  used as look-up keys, this causes problems.</para>

	<para>In these cases, you should add extra characters to
	  the strings. For instance, use <literal>"jumps[noun]"</literal> and
	  <literal>"jumps[verb]"</literal> instead of just
	  <literal>"jumps"</literal>) and strip them again outside the
	  <literal>gettext</literal> call. If you add extra
	  characters you should also add a
	  comment for the translators before the <literal>gettext</literal> call.
	  Such comments will be shown in the <filename>.po</filename>
	  files. For instance,</para>

	<programlisting>
// note to translators: don't translate the "[noun]" part - it is
// just here to distinguish the string from another "jumps" string
text = strip(gettext("jumps[noun]"), "[noun]");</programlisting>
      </sect2>

      <sect2>
	<title>Composition of strings</title>

	<para>C programmers use
	  <literal>sprintf()</literal> to compose and concatenate strings. C++ favours streams, but unfortunately, this approach makes translation difficult, because each fragment of text is translated separately, without allowing the translators to rearrange them according to the grammar of the language.</para>

	<para>For instance, this code would be problematic:</para>

	<programlisting>
std::cout &lt;&lt; _("Current amount: ") &lt;&lt; amount
	  &lt;&lt; _(" Future: ") &lt;&lt; future &lt;&lt; std::endl;

label.set_text(_("Really delete ") + filename + _(" now?"));
</programlisting>

	<para>So you should either avoid this situation or revert to the C-style <literal>sprintf()</literal>.  One
	  possible solution is the <ulink
	  url="http://www.cs.auc.dk/~olau/compose/">compose
	  library</ulink> which supports syntax such as:</para>

	<programlisting>
label.set_text(compose(_("Really delete %1 now?"), filename));</programlisting>
      </sect2>
      
      <sect2>
	<title>Assuming the displayed size of strings</title>

	<para>You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most <literal>gtkmm</literal> widgets will expand at runtime to the required size.</para>
      </sect2>

      <sect2>
	<title>Unusual words</title>

	<para>You should avoid cryptic abbreviations, slang, or jargon.
	  They are usually difficult to translate, and are often difficult
for even native speakers to understand. For instance, prefer &quot;application&quot; to &quot;app&quot;</para>
      </sect2>

      <sect2>
	<title>Using non-ASCII characters in strings</title>

	<para>Currently, <application>gettext</application> does not support
	  non-ASCII characters (i.e. any characters with a code above
	  127) in source code. For instance, you cannot use the copyright sign (&copy;).</para>

	<para>To work around this, you could write a comment in the
	  source code just before the string, telling the translators to
	  use the special character if it is available in their languages. For english, you could then make an American English
	  <filename>en_US.po</filename> translation which used that special charactger.</para>
      </sect2>
    </sect1>

    <sect1 id="sec-getting_help_with_translations">
      <title>Getting help with translations</title>

      <para>If your program is free software, there is a whole <literal>GNOME</literal>
	subproject devoted to helping you make translations, the
	<ulink url="http://developer.gnome.org/projects/gtp/"><literal>GNOME</literal>
	Translation Project</ulink>.</para>

      <para>The way it works is that you contact the gnome-i18n
	mailing list to find out how the translators can access your
	<filename>po/</filename> subdirectory, and to add your project
	to the big <ulink
	url="http://developer.gnome.org/projects/gtp/status/">status
	tables</ulink>.</para>

      <para>Then you make sure you update the file
	<filename>POTFILES.in</filename> in the
	<filename>po/</filename> subdirectory
	(<command>intltool-update -M</command> can help with this) so
	that the translators always access updated
	<filename>myprogram.pot</filename> files, and simply freeze
	the strings at least a couple of days before you make a new
	release, announcing it on gnome-i18n. Depending on the number
	of strings your program contains and how popular it is, the
	translations will then start to tick in as
	<filename>languagename.po</filename> files.</para>

      <para>Note that most language teams only consist of 1-3 persons,
	so if your program contains a lot of strings, it might last a
	while before anyone has the time to look at it. Also, most
	translators do not want to waste their time (translating is
	a very time-consuming task) so if they do not assess your
	project as being really serious (in the sense that it is
	polished and being maintained) they may decide to spend their
	time on some other project.</para>
    </sect1>
</chapter>

<chapter id="sec-customwidgets">
    <title>Custom Widgets</title>

    <para><literal>gtkmm</literal> makes it very easy to derive new widgets by inheriting from an existing widget class, either by deriving from a container and adding child widgets, or by deriving from a single-item widget, and changing its behaviour. But you might occasionally find that no suitable starting point already exists. In this case, you can implement a widget from scratch.</para>
    <sect1>
    <title>Custom Containers</title>
    <para>When deriving from Gtk::Container, you should override the following virtual methods:
    <itemizedlist>
      <listitem><para><literal>on_size_request()</literal>: Calculate the minimum height and width needed by the container.</para></listitem>
      <listitem><para><literal>on_size_allocate()</literal>: Position the child widgets, given the height and width that the container has actually been given.</para></listitem>
      <listitem><para><literal>forall_vfunc()</literal>: Call the same callback for each of the children.</para></listitem>
      <listitem><para><literal>on_add()</literal>: </para></listitem>
      <listitem><para><literal>on_remove()</literal>: </para></listitem>
      <listitem><para><literal>child_type_vfunc()</literal>: Return what type of child can be added.</para></listitem>
    </itemizedlist>
    </para>

    <para>The <literal>on_size_request()</literal> and <literal>on_size_allocate()</literal> virtual methods control the layout of the child widgets. For instance, if your container has 2 child widgets, with one below the other, your <literal>on_size_request()</literal> might report the maximum of their widths and the sum of their heights. If you want padding between the child widgets then you would add that to the width and height too. Your widget's container will use this result to ensure that your widget gets enough space, and not less. By examining each widget's parent, and its parent, this logic will eventually decide the size of the top-level window.</para>

   <para><literal>on_size_allocate()</literal>, however, receives the actual height and width that the parent container has decided to give to your widget. This might be more than the minimum, for instance if the top-level window has been expanded. You might choose to ignore the extra space and leave a blank area, or you might choose to expand your child widgets to fill the space, or you might choose to expand the padding between your widgets. Its your container, so you decide. Don't forget to call <literal>set_allocation</literal> inside your <literal>on_size_allocate()</literal> implementation to actually use the allocated space that has been offered by the parent container.</para>

  <para>Unless your container is a top-level window that derives from Gtk::Window, you should also call <literal>Gtk::Container::set_flags(Gtk::NO_WINDOW)</literal> in your constructor. Otherwise, your container will appear in its own window, regardless of what container you put it in. And unless your container draws directly onto the underlying Gdk::Window, you should probably call <literal>set_redraw_on_allocate(false)</literal> to improve performance.</para>

  <para>By overriding <literal>forall_vfunc()</literal> you can allow applications to operate on all of the container's child widgets. For instance, <literal>show_all_children</literal> uses this to find all the child widgets and show them.</para>
 
  <para>Although your container might have its own method to set the child widgets, you should still provide an implementation for the virtual <literal>on_add()</literal> and <literal>on_remove()</literal> methods from the base class, so that the add() and remove() methods will do something appropriate if they are called.</para>

  <para>Your implementation of the <literal>child_type_vfunc()</literal> method should report the type of widget that may be added to your container, if it is not yet full. This is usually Gtk::Widget::get_type() to indicate that the container may contain any class derived from Gtk::Widget. If the container may not contain any more widgets, then this method should return G_TYPE_NONE.</para> 


<sect2><title>Example</title>

<para>This example implements a container with two child widgets, one above the other. Of course, in this case it would be far simpler just to use a Gtk::VBox.</para>

<figure id="figure-custom-container">
  <title>Custom Container</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;custom_container.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;custom/custom_container/">Source Code</ulink></para>
</sect2>

    </sect1>  

    <sect1>
    <title>Custom Widgets</title>
    <para>By deriving directly from <literal>Gtk::Widget</literal> you can do all the drawing for your widget directly, instead of just arranging child widgets. For instance, a Gtk::Label draws the text of the label, but does not do this by using other widgets.</para>

<sect2><title>Example</title>

<para>This example implements a widget which draws a square.</para>

<figure id="figure-custom-widget">
  <title>Custom Widget</title>
  <screenshot>
    <graphic format="PNG" fileref="&url_figures_base;custom_widget.png"/>
  </screenshot>
</figure>

<para><ulink url="&url_examples_base;custom/custom_widget/">Source Code</ulink></para>
</sect2>

    </sect1>



</chapter>
  
<chapter id="sec-gathering">
<title>Recommended Techniques</title>

<para>This section is simply a gathering of wisdom, general style guidelines
and hints for creating gtkmm applications.
</para>

<para>Use GNU autoconf and automake! They are your friends :) Automake
examines C files, determines how they depend on each other, and
generates a Makefile so the files can be compiled in the correct
order. Autoconf permits automatic configuration of software
installation, handling a large number of system quirks to increase
portability..
</para>

<para>Subclass Widgets to better organise your code. You should probably subclass your main Window at least. Then you can make your child Widgets and signal handlers members of that class.
</para>

<para>Create your own signals instead of passing pointers around. Objects can communicate with each other via signals and signal handlers. This is much simpler than objects holding pointers to each other and calling each other's methods. gtkmm's classes uses special versions of Sigc::Signal, but you should use normal sigc::signals, as described in the libsigc++ documentation.</para>

<sect1><title>Application lifetime</title>
<para>Most applications will have only one window, or only one main window. These applications can use the Gtk::Main::run(Gtk::Window&amp;) overload. It shows the window and returns when the window has been hidden. This might happen when the user closes the window, or when your code decides to hide() the window. You can prevent the user from closing the window (for instance, if there are unsaved changes) by overriding Gtk::Window::on_delete_event().</para>
<para>Most of our examples use this technique.</para>
</sect1>

<sect1 id="sec-using_a_gtkmm_widget">
<title>Using a gtkmm widget</title>

<para>
Our examples all tend to have the same structure. They follow these steps for using a Widget:

</para>

<para>

<orderedlist>
<listitem>
<para>
Declare a variable of the type of Widget you wish to use, generally as member variable of a derived container class. You could also declare a pointer
to the Widget type, and then create it with <literal>new</literal> in your code. Even when using the widget via a pointer, it's still probably best to make that pointer a member variable of a container class so that you can access it later.
</para>
</listitem>

<listitem>
<para>
 Set the attributes of the widget. If the Widget has no default constructor, then you will need to initialize the widget in the initalizer list of your container class's constructor.
</para>
</listitem>

<listitem>
<para>
Connect any signals you wish to use to the
appropriate handlers.
</para>
</listitem>

<listitem>
<para>
Pack the widget into a container using the appropriate call,
e.g. <literal>Gtk::Container::add()</literal> or <literal>pack&lowbar;start()</literal>.
</para>
</listitem>

<listitem>
<para>
Call <literal>show()</literal> to display the widget.
</para>
</listitem>

</orderedlist>

</para>

<para>
<literal>Gtk::Widget::show()</literal> lets gtkmm know that we have finished setting the
attributes of the widget, and that it is ready to be displayed. You
can use <literal>Gtk::Widget::hide()</literal> to make it disappear again. The order
in which you show the widgets is not important, but we do suggest
that you show the top-level window last; this way, the whole window
will appear with its contents already drawn.  Otherwise, the user will
first see a blank window, into which the widgets will be gradually drawn.
</para>

</sect1>
</chapter>

<chapter id="sec-Contributing">
<title>Contributing </title>

<para>
This document, like so much other great software out there, was
created for free by volunteers.  If you are at all knowledgeable about
any aspect of gtkmm that does not already have documentation, please
consider contributing to this document.
</para>
<para>
Ideally, we would like you to provide a patch to the docs/tutorial/gtkmm-tut.xml file. 
This file is currently in the gtkmm2 module in gnome cvs.
</para>

<para>
If you do decide to contribute, please post your contribution to the
gtkmm mailing list at <ulink url="mailto:gtkmm-list@gnome.org">&#60;gtkmm-list@gnome.org&#62;</ulink>.  Also, be aware that
the entirety of this document is free, and any addition you provide
must also be free. That is, people must be able to use any portion of
your examples in their programs, and copies of this document
(including your contribution) may be distributed freely.
</para>

</chapter>

<appendix id="sec-appendix-refptr">
<title>The RefPtr smartpointer</title>
<para>
Glib::RefPtr is a smartpointer. Specifically, it is a
reference-counting smartpointer. You might be familiar with
<literal>std::auto_ptr&lt;&gt;</literal>, which is also a smartpointer, but <literal>Glib::RefPtr&lt;&gt;</literal> is
much simpler, and more useful. We expect a future version of the
C++ Standard Library to contain a reference-counting shared
smartpointer, so a future version of gtkmm will probably use that
instead.</para>

<para><ulink url="&url_refdocs_base_glib;RefPtr.html">Reference</ulink></para>

<para>A smartpointer acts much like a normal pointer. Here are a few examples.</para> 

<sect1><title>Copying</title>
<para>You can copy RefPtrs, just like normal pointers. But unlike
normal pointers, you don't need to worry about deleting the underlying
instance
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap2 = refBitmap;
</programlisting>
</para>
<para>Of course this means that you can store RefPtrs in standard
containers, such as std::vector or std::list.</para>
<para>
<programlisting>
std::list&lt; Glib::RefPtr&lt;Gdk::Pixmap&gt; &gt; listPixmaps;
Glib::RefPtr&lt;Gdk::Pixmap&gt; refPixmap = Gdk::Pixmap::create(window,
width, height, depth);
listPixmaps.push_back(refPixmap);
</programlisting>
</para>
</sect1>

<sect1 id="sec-dereferencing"><title>Dereferencing</title>
<para>You can dereference a smartpointer with the -&gt; operator, to
call the methods of the underlying instance, just like a normal pointer.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
int depth = refBitmap-&gt;get_depth();
</programlisting>
</para>
<para>But unlike most smartpointers, you can't use the * operator to
access the underlying instance.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
Gdk::Bitmap* underlying = *refBitmap; //Syntax error - will not compile.
</programlisting>
</para>
</sect1>

<sect1 id="sec-casting"><title>Casting</title>
<para>You can cast RefPtrs to base types, just like normal pointers.</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;
</programlisting>
</para>
<para>This means that any method which takes a <literal>const
Glib::RefPtr&lt;BaseType&gt;</literal> argument can also take a
<literal>const Glib::RefPtr&lt;DerivedType&gt;</literal>. The cast is
implicit, just as it would be for a normal pointer.</para> 
<para>You can also cast to a derived type, but the syntax is
a little different than with a normal pointer.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =
Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =
Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);
</programlisting>
</para>
</sect1>


<sect1 id="sec-checking_for_null"><title>Checking for null</title>
<para>Just like normal pointers, you can check whether a RefPtr points
to anything.</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();
if(refModel)
{
  int cols_count = refModel-&gt;get_n_columns();
  ...
}
</programlisting>
</para>
<para>But unlike normal pointers, RefPtrs are automatically
initialized to null so you don't need to remember to do that yourself.
</para>
</sect1>


<sect1 id="sec-constness"><title>Constness</title>
<para>The use of the const keyword in C++ is not always clear. You
might not realise that <literal>const Something*</literal> declares a
pointer to a const Something, The pointer can be changed, but not the
Something that it points to.</para>
<para>Therefore, the RefPtr equivalent of
<literal>Something*</literal> for a method parameter is <literal>const
Glib::RefPtr&lt;Something&gt;&amp;</literal>, and the equivalent of
<literal>const Something*</literal> is <literal>const Glib::RefPtr&lt;const
Something&gt;&amp;</literal>.</para>
<para>The <literal>const ... &amp;</literal> around
both is just for efficiency, like using <literal>const std::string&amp;</literal>
instead of <literal>std::string</literal> for a method parameter to
avoid unnecessary copying.</para> 
</sect1>

</appendix>


<appendix id="sec-appendix-signals">
<title>Signals</title>

<sect1>
<title>Connecting signal handlers</title>
<para>
gtkmm widget classes have signal accessor methods, such as Gtk::Button::signal_clicked, which allow you to connect your signal handler. Thanks to the flexibility of libsigc++, the callback library used by
gtkmm, the signal handler can be almost any kind of function, but you will probably want to use a class method. Among GTK+ C coders, these signal handlers are often
named callbacks.
</para>

<para>
Here's an example of a signal handler being connected to a signal:
</para>

<para>
<programlisting>
#include &#60;gtkmm/button.h&#62;

void on_button_clicked()
{
    std::cout &#60;&#60; "Hello World" &#60;&#60; std::endl;
}

main()
{
    Gtk::Button button("Hello World");
    button.signal_clicked().connect(sigc::mem_fun(&amp;on_button_clicked));
}
</programlisting>
</para>

<para>
There's rather a lot to think about in this (non-functional) code.
First let's identify the parties involved:
</para>

<para>

<itemizedlist>
<listitem>

<para>
The signal handler is <literal>on_button_clicked()</literal>.
</para>
</listitem>
<listitem>

<para>
We're hooking it up to the <literal>Gtk::Button</literal> object called <literal>button</literal>.
</para>
</listitem>
<listitem>

<para>
When the Button emits its <literal>clicked</literal> signal, <literal>on_button_clicked()</literal> will be
called.
</para>
</listitem>

</itemizedlist>

</para>

<para>
Now let's look at the connection again::
</para>

<para>
<programlisting>
    ...
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
    ...
</programlisting>
</para>

<para>
Note that we don't pass a pointer to <literal>on_button_clicked()</literal> directly to the signal's
<literal>connect()</literal> method.  Instead, we call <literal>sigc::ptr_fun()</literal>, and pass the result to
<literal>connect()</literal>.  What's that <literal>sigc::ptr_fun()</literal> function for?
</para>

<para>
sigc::ptr_fun() is a <literal>factory function</literal> which generates
<literal>sigc::pointer_functors</literal> that are implicitly converted into sigc::slots.
A slot is an object which looks and feels like a function, but is actually an object.
These are also known as <literal>function objects</literal>, or <literal>functors</literal>.
<literal>sigc::pointer_functors</literal> are functors as well and there are many other functor
types like, e.g., <literal>sigc::mem_functors</literal> which are generated by sigc::mem_fun().
Any functor that can be called with the argument types of the slot can be implicitely converted
into a slot, i.e. you can pass any compatible functor into a function that expects a sigc::slot.
</para>

<para>
Here's a slightly larger example of slots in action:
</para>

<para>
<programlisting>
void on_button_clicked();

class some_class
{
    void on_button_clicked();
};

some_class some_object;

main()
{
    Gtk::Button button;
    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );
    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );
}
</programlisting>
</para>

<para>
The first call to <literal>connect()</literal> is just like the one we saw last
time; nothing new here.  The next is more interesting.  <literal>sigc::mem_fun()</literal> is
called with two arguments.  The first argument
is "some_object", which is the object that our new slot will be pointing at; the
second argument is a pointer to one of its methods.  This particular
version of <literal>sigc::mem_fun()</literal> creates a slot which will, when "called", call
the pointed-to method of the specified object, in this case
some_object.on_button_clicked().
</para>

<para>
Another thing to note about this example is that we placed the call to
<literal>connect()</literal> twice for the same signal object.  This is perfectly
fine - when the button is clicked,
both signal handlers will be called.
</para>

<para>
We just told you that the button's <literal>clicked</literal> signal is expecting
to call a method with no arguments.  All signals have
requirements like this; you can't hook a function with two arguments
to a signal expecting none (unless you use an
adapter, such as sigc::bind, of course).  Therefore, it's important to know what type of
signal handler you'll be expected to connect to a given signal.
</para>
</sect1>

<sect1 id="sec-writing_signal_handlers">
<title>Writing signal handlers</title>

<para>
To find out what type of signal handler you can connect to a signal, you can
look it up in the reference documentation or the header file. Here's an example of a signal declaration you
might see in the gtkmm headers:
</para>

<para>
<programlisting>
Glib::SignalProxy1&lt;bool, GtkDirectionType&gt; signal_focus() 
</programlisting>
</para>

<para>
Other than the signal's name (<literal>focus</literal>), two things are
important to note here: the number following the word <literal>SignalProxy</literal> at
the beginning (1, in this case), and the types in the list
(<literal>bool</literal> and <literal>GtkDirectionType</literal>).  The number indicates how many
arguments the signal handler should have; the first type, <literal>bool</literal>,
is the type that the signal handler should return; and the next type,
<literal>GtkDirectionType</literal>, is the type of this signal's first, and only,
argument. By looking at the reference documentation, you can see the names of the arguments too.
</para>

<para>
The same principles apply for signals which have more
arguments.  Here's one with three (taken from
<literal>&lt;gtkmm/editable.h&gt;</literal>):
</para>

<para>
<programlisting>
Glib::SignalProxy3&lt;void, const Glib::ustring&amp;, int, int*&gt; signal_insert_text()

</programlisting>
</para>

<para>
It follows the same form.  The
number 3 at the end of the type's name indicates that our signal handler
will need three arguments.  The first type in the type list is
<literal>void</literal>, so that should be our signal handler's return type.  The
following three types are the argument types, in order. Our signal handler's prototype could look like this:
</para>

<para>
<programlisting>
void on_insert_text(const Glib::ustring&amp; text, int length, int* position);
</programlisting>
</para>
</sect1>

<sect1 id="sec-disconnecting_signal_handlers">
<title>Disconnecting signal handlers</title>

<para>
Let's take another look at a Signal's <literal>connect</literal> method:
</para>

<para>
<programlisting>
sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );
</programlisting>
</para>

<para>
Notice that the return value is of type <literal>sigc::signal&lt;void,int&gt;::iterator</literal>.
This can be implicitely converted into a <literal>sigc::connection</literal> which in turn
can be used to control the connection. By keeping a connection object you can disconnect its
associated signal handler using the method <literal>sigc::connection::disconnect()</literal>.
</para>

</sect1>
<sect1 id="sec-overriding_default_signal_handlers">
<title>Overriding default signal handlers</title>

<para>
So far we've told you to perform actions in
response to button-presses and the like by handling signals.
That's certainly a good way to do things, but it's not the only
way.
</para>

<para>
Instead of laboriously connecting signal handlers to signals,
you can simply make a new class which inherits from a widget - say, a
Button - and then override the default signal handler, such as Button::on_clicked().  This can be a
lot simpler than hooking up signal handlers for everything.
</para>

<para>
Subclassing isn't always the best way to accomplish
things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects.
</para>

<para>
gtkmm classes are designed with overriding in mind; they contain
virtual member methods specifically intended to be overridden.
</para>

<para>
Let's look at an example of overriding:
</para>

<para>
<programlisting>
#include &#60;gtkmm/button.h&#62;

class OverriddenButton : public Gtk::Button
{
protected:
    virtual void on_clicked();
}

void OverriddenButton::on_clicked()
{
    std::cout &#60;&#60; "Hello World" &#60;&#60; std::endl;

    // call the base class's version of the method:
    Gtk::Button::on_clicked();
}
</programlisting>
</para>

<para>
Here  we define a new class called
<literal>OverriddenButton</literal>, which inherits from <literal>Gtk::Button</literal>.  The
only thing we change is the <literal>on_clicked</literal> method, which is
called whenever <literal>Gtk::Button</literal> emits the <literal>clicked</literal> signal.  This method prints "Hello World" to <literal>stdout</literal>, and then
calls the original, overridden method, to let <literal>Gtk::Button</literal> do
what it would have done had we not overridden.
</para>

<para>
You don't always need to call the parent's method; there are times
when you might not want to.  Note that we called the parent method
<emphasis>after</emphasis> writing "Hello World", but we could have called it before.
In this simple example, it hardly matters much, but there are times
when it will.  With signals, it's not quite so easy to change details
like this, and you can do something here which you can't do at all
with connected signal handlers: you can call the parent method in the <emphasis>middle</emphasis> of
your custom code.
</para>

</sect1>

<sect1 id="sec-binding_extra_arguments">
<title>Binding extra arguments</title>
<para>
If you use one signal handler to catch the same signal from several widgets, you might like that signal handler to receive some extra information. For instance, you might want to know which button was clicked. You can do this with <literal>sigc::bind()</literal>. Here's some code from the <link linkend="sec-helloworld2">helloworld2</link> example, which you will encounter later.
<programlisting>
m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1") );
</programlisting>
This says that we want the signal to send an extra Glib::ustring argument to the signal handler, and that the value of that argument should be "button 1". Of course we will need to add that extra argument to the declaration of our signal handler:
<programlisting>
virtual void on_button_clicked(Glib::ustring data);
</programlisting>
Of course, a normal "clicked" signal handler would have no arguments.
</para>
<para>
sigc::bind() is not commonly used, but you might find it helpful sometimes. If you are familiar with GTK+ programming then you have probably noticed that this is similar to the extra <literal>gpointer data</literal> arguments which all GTK+ callbacks have. This is generally overused in GTK+ to pass information that should be stored as member data in a derived Widget, but Widget derivation is very difficult in C. We have far less need of this hack in gtkmm.</para>  
</sect1>

<sect1 id="sec-xeventsignals">
<title>X Event signals</title>
<para>The Widget class has some special signals which correspond to the underlying X-Windows events. These are suffixed by <literal>_event</literal>; for instance, <literal>Widget::signal_button_pressed_event()</literal>.</para>
<para>
You might occasionally find it useful to handle X events when there's something you
can't accomplish with normal signals.  <literal>Gtk::Button</literal>, for
example, does not send mouse-pointer coordinates with its <literal>clicked</literal>
signal, but you could handle <literal>button&lowbar;pressed&lowbar;event</literal> if you needed this information.  X events are also
often used to handle key-presses.
</para>

<para>
These signals behave slightly differently.  The value returned from the signal handler indicates whether it has fully "handled"
the event.  If the value is <literal>false</literal> then gtkmm will pass the event on to the next signal handler.  If the value is <literal>true</literal> then no other signal handlers will need to be called.
</para>

<para>
Handling an X event doesn't affect the Widget's other
signals.  If you handle <literal>button&lowbar;pressed&lowbar;event</literal> for
<literal>Gtk::Button</literal>, you'll still be able to get the <literal>clicked</literal> signal.
They are emitted at (nearly) the same time.
</para>

<para>
Here's a simple example:
<programlisting>
bool on_button_press(GdkEventButton* event);
Gtk::Button button("label");
button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );
</programlisting>
</para>
<para>
When the mouse is over the button and a mouse button is pressed,
<literal>on&lowbar;button&lowbar;pressed()</literal> will be called.
</para>

<para>
<literal>GdkEventButton</literal> is a structure containing the event's parameters,
such as the coordinates of the mouse pointer at the time the button
was pressed.  There are several different types of <literal>GdkEvent</literal>
structures for the various events.
</para>
</sect1>

</appendix>



<appendix id="sec-appendix-custom_signals">
<title>Creating your own signals</title>
<para>
Now that you've seen signals and signal handlers in gtkmm, you
might like to use the same technique to allow interaction between your
own classes. That's actually very simple by using the libsigc++
library directly.
</para>
<para>
This isn't purely a gtkmm or GUI issue. gtkmm uses libsigc++ to
implement its proxy wrappers for the GTK+ signal system, but for new,
non-GTK+ signals, you can create pure C++ signals, using the
sigc::signal&lt;&gt; template.
</para>
<para>
For instance, to create a signal that sends 2 parameters, a bool and
an integer, just declare a sigc::signal, like so:
<programlisting>
sigc::signal&lt;void, bool int&gt; signal_something;
</programlisting>
</para>
<para>
You could just declare that signal as a public member variable, but
some people find that distasteful and prefer to make it available via
an accessor method, like so:
<programlisting>
class Server
{
  //signal accessor:
  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}
</programlisting> 
</para>

<para>
You can then connect to the signal using the same syntax used when
connecting to gtkmm signals. For instance,
<programlisting>
server.signal_something().connect(
  sigc::mem_fun(client, &amp;Client::on_server_something) );
</programlisting>
</para>
<para>
See <emphasis>examples/book/signals/custom/</emphasis> for a full
working example.
</para>

</appendix>




<appendix id="sec-signals-comparison">
<title>Comparison with other signalling systems</title>
<para>
TODO: Rewrite this paragraph and talk about QT's moc. 
(An aside: GTK+ calls this scheme "signalling"; the sharp-eyed reader
with GUI toolkit experience will note that this same design is often
seen under the name of "broadcaster-listener" (e.g., in Metrowerks'
PowerPlant framework for the Macintosh).  It works in much the same
way: one sets up <literal>broadcasters</literal>, and then connects
<literal>listeners</literal> to them; the broadcaster keeps a list of the
objects listening to it, and when someone gives the broadcaster a
message, it calls all of its objects in its list with the message.  In
gtkmm, signal objects play the role of broadcasters, and slots
play the role of listeners - sort of.  More on this later.)
</para>
<para>
 gtkmm signal handlers are strongly-typed,
 whereas GTK+ C code allows you to connect a callback with the wrong number and type of arguments, leading to a segfault at runtime. And, unlike QT, gtkmm achieves this without modifying the C++ language.</para>
<para>
Re. Overriding signal handlers: You can do this in the straight-C world of GTK+ too; that's what GTK's
object system is for.  But in GTK+, you have to go through some
complicated procedures to get object-oriented features like
inheritance and overloading.  In C++, it's simple, since those
features are supported in the language itself; you can let the
compiler do the dirty work.
</para>
<para>
This is one of the places where the beauty of C++ really comes out.
One wouldn't think of subclassing a GTK+ widget simply to override its
action method; it's just too much trouble.  In GTK+, you almost always
use signals to get things done, unless you're writing a new widget.
But because overriding methods is so easy in C++, it's entirely
practical - and sensible - to subclass a button for that purpose.
</para>
</appendix>

<appendix id="sec-windows-installation">
	<title>gtkmm and Win32</title>
    <para>
      One of the major advantages of gtkmm is that it is crossplatform. gtkmm programs written on other platforms such as
      GNU/Linux can generally be transferred to Windows (and vice
      versa) with few modifications to the source.
    </para>
    <para>
      gtkmm currently only works with the <ulink
	url="http://mingw.org/">MingW/GCC3.2 compiler</ulink> on the
      Windows platform. This is unlikely to change in the near
      future, unless Microsoft upgrades its compilers in Visual
      Studio to fully support the C++ standard. Information about the gtkmm and the latest Microsoft C++ compiler might be on the mailing list.
    </para>
    <para>
      Installation of MingW is beyond the scope of this document, though not excessively difficult.
      However, a good GPL'd C++ IDE for windows called <ulink
	url="http://www.bloodshed.net/">Dev-C++</ulink> has a
      convenient Windows installer that installs both the IDE and
      the MingW/GCC3.2 compiler, and we can recommend it.  We will now 
      show step by step how to install gtkmm and properly set
      up Dev-C++ as your gtkmm development environment. The following
	  instructions should work for Dev-C++ versions 4.9.8.0 or higher.
	  For people who prefer command line compiler tools, a solution based
	  on the cygwin distribution will be described in the last section of
      this chapter.
    </para>
    <sect1>
      <title>The Dev-C++ IDE</title>
      <sect2>
	<title>Pre-Installation Issues</title>
	<para>
	  We strongly recommend that Dev-C++ is installed and
	  tested before installing any of the GTK+ or gtkmm libraries,
	  as we will be installing all the libraries into the Dev-C++
	  directory.  Ensure that you are able to successfully compile and
	  run a simple C++ program from Dev-C++ before proceeding to the
	  next step. For instance, try a simple Hello World program.
	</para>
	<para>
	  Note: Currently (as of v4.9.8.0) Dev-C++ does not like to be
	  installed in directories with spaces in them. Installing
	  Dev-C++ to the "Program Files" directory may cause problems at
	  a later stage when it looks for the include and lib
	  directories.
	</para>
      </sect2>

      <sect2>
	<title>Dependencies</title>
	<para>
	  The gtkmm Windows installer requires you to first
	  install the following dependencies:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>GTK+ 2.x</para>
	    <para>
	      Before installing gtkmm, you need to install the latest GTK+ 2.x.  You
	      can find the latest windows installer at <ulink
		url="http://gladewin32.sourceforge.net/">Glade/Gtk+ for Win32</ulink>. The Windows
	      installer will correctly install any dependencies that GTK+
	      2.x may need.
	    </para>
	    <para>
		  You will need to download and install the Gtk+/Win32 Development
		  Environment.  This includes the runtime, devel, docs, and glade.
	      Start with the Development GTK+ installer, and allow the
	      installation to proceed to the default directory.  
	    </para>
	  </listitem>
	</itemizedlist>
      </sect2>

      <sect2>
	<title>Installation</title>
	<para>
	  Now you are ready to install gtkmm. You can find a link to an installer on the <ulink url="http://www.gtkmm.org/">gtkmm web site's</ulink> download page.
	  The gtkmm Windows installer includes both the development
	  and the runtime files.
	</para>
	<para>
	  Since we are going to be using Dev-C++ as our IDE, it is
	  strongly suggested that you install gtkmm into the base
	  Dev-C++ directory (ie. d:\dev-cpp). This will make things
	  easier later on when setting up the include and lib
	  directories in Dev-C++.
	</para>
	<para>
	  You should now be ready to execute Win32 gtkmm compiled
	  binaries.  Note: Some older versions of Windows may require a reboot
	  before the installer's change to the PATH variable takes effect.
	</para>
      </sect2>

      <sect2>
	<title>Compiling gtkmm Apps with Dev-C++</title>
	<para>
	  Now we need to set some project options to create our
	  first gtkmm project in Dev-C++.
	</para>
	<para>
	  First, we need to let Dev-C++ know what files and libraries to
	  include when it invokes MingW/GCC3.2. To find out what
	  arguments need to be passed to GCC, we need to open a command
	  prompt and type the following:
	</para>
	<para>
	  <command>
	    pkg-config --cflags gtkmm-2.4
	  </command>
	</para>
	<para>
	  If the pkg-config command cannot be found, you can cd to the
	  bin/ directory of where you installed Dev-C++ and execute the
	  above line from there.  Depending on where you installed
	  gtkmm, you will get output that looks similar to the
	  following:
	</para>
	<para>
	  <programlisting>
	    -Id:/dev-c++/include/gtkmm-2.4
	    -Id:/dev-c++/lib/gtkmm-2.4/include
	    -Id:/dev-c++/include/gtk-2.0
	    -Id:/dev-c++/lib/sigc++-2.0/include
	    -Id:/dev-c++/include/sigc++-2.0
	    -Id:/dev-c++/include/glib-2.0
	    -Id:/dev-c++/lib/glib-2.0/include
	    -Id:/dev-c++/lib/gtk-2.0/include
	    -Id:/dev-c++/include/pango-1.0 -Id:/dev-c++/include/atk-1.0
	    -Ld:/dev-c++/lib 
	  </programlisting>
	</para>
	<para>
	  The next step is to obtain the list of libraries by issuing the following
	  command:
	</para>
	<para>
	  <command>
	    pkg-config --libs gtkmm-2.4
	  </command>
	</para>
	<para>
	  Your results may look something similar to this:
	</para>
	<para>
	  <programlisting>
	    -lgtkmm-2.4 -lgdkmm-2.4 -latkmm-1.0
	    -lgtk-win32-2.0 -lpangomm-1.4 -lglibmm-2.4 -lsigc-2.0
	    -lgdk-win32-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lpangowin32-1.0
	    -lgdi32 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -lglib-2.0
	    -lintl -liconv
	  </programlisting>
	</para>

	<para>
	  <figure id="figure-project-options">
	    <title>Dev-C++ Project Options</title>
	    <screenshot>
	      <graphic format="PNG" fileref="&url_figures_base;devcpp_project_options.png"/>
	    </screenshot>
	  </figure>
	</para>

	<para>
	  Now create a new Project.  We will make this project work with
	  gtkmm.  After creating a new project, select <literal>Project Options</literal>
	  from the menu, and under the <literal>Parameters</literal> tab, we will need to enter the information
	  we obtained earlier:  In the <literal>Additional commandline options</literal> for
	  the C++ compiler, paste the include and lib <emphasis>directories</emphasis> you obtained with
	  the --cflags argument. (The commandline options preceeded by either an -I or a -L).
	</para>

	<para>
	  Now we must tell the linker what libraries to include, by pasting the libraries into the <literal>Additional commandline options</literal> for the Linker. (These commandline options are preceeded by a -l).
	</para>

	<para>
	  Congratulations. You have successfully created a new project in Dev-C++ that
	  works with gtkmm.  Try compiling some of the examples in this
	  tutorial.
	</para>
    </sect2>
    </sect1>

    <sect1 id="sec-build_with_command_line_tools">
      <title>Command line tools</title>
      <para>
	To build your gtkmm application with command line tools, we recommend you either use mingw combined with cygwin
	(<ulink url="http://www.cygwin.com"></ulink>) or msys (<ulink
	  url="http://www.mingw.org"></ulink>). If you use
	mingw/cygwin, make sure that the directory that contains the
	mingw executables is first in your PATH (by checking with g++
	-v). Then
      </para>
      <para>
	<orderedlist>
	  <listitem>
	    <para>Add the directories with the gtkmm and gtk+ DLLs and
	      the gtk+ executables (particularly the one containing
	      pkg-config.exe) to your path. If you have selected the
	      corresponding option in the gtkmm installer, both the
	      gtkmm and gtk+ runtime will already be in your
	      PATH. Make sure pkg-config is available by typing
	      <command>'pkg-config --version'</command>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>Set the PKG_CONFIG_PATH environment variable to
	      point to the various lib/pkgconfig directories. Look for
	      files with the .pc extension in the gtk+ and gtkmm
	      developer packages. It's the same syntax as on
	      linux but the directories are separated by semicolons.</para>
	  </listitem>
	  <listitem>
	    <para>Check the gtkmm distribution by typing
	      <command>'pkg-config --modversion --cflags --libs
		gtkmm-2.4'</command>. You should get something like
	    </para>
	    <para><programlisting>
		2.2.1
		-IC:/target/libsigc/lib/sigc++-2.0/include
		-IC:/target/libsigc/include/sigc++-2.0
		-IC:/target/gtkmm/include/gtkmm-2.4
		-IC:/target/gtkmm/lib/gtkmm-2.4/include
		-IC:/target/gtk-2.0/include/gtk-2.0
		-IC:/target/gtk-2.0/include/glib-2.0
		-IC:/target/gtk-2.0/lib/glib-2.0/include
		-IC:/target/gtk-2.0/lib/gtk-2.0/include
		-IC:/target/gtk-2.0/include/pango-1.0
		-IC:/target/gtk-2.0/include/atk-1.0
		-LC:/target/libsigc/lib
		-LC:/target/gtkmm/lib
		-LC:/target/gtk-2.0/lib -lgtkmm-2.4
		-lgdkmm-2.4 -latkmm-1.4 -lgtk-win32-2.0 -lpangomm-1.4
		-lglibmm-2.4 -lsigc-2.0 -lgdk-win32-2.0 -latk-1.0
		-lgdk_pixbuf-2.0 -lpangowin32-1.0 -lgdi32 -lpango-1.0
		-lgobject-2.0 -lgmodule-2.0 -lglib-2.0 -lintl
		-liconv</programlisting>
	    </para>
	    <para>Of course, the target directories will show your local
	      installation tree.
	    </para>
	  </listitem>
	  <listitem>
	    <para>You can compile a single source file like so:</para>
	    <para>
	      <command>g++ `pkg-config --cflags gtkmm-2.4`
		my_programs.cc -o my_program `pkg-config --libs
		gtkmm-2.4`</command>
	    </para>
	  </listitem>
	</orderedlist>
      </para>
      <para>
	See the gtkmm FAQ for more build help.
      </para>
    </sect1>

  <sect1 id="sec-building_on_win32">
	<title>Building gtkmm on Win32</title>
    <para>Please see the appropriate README file in the source distribution.
    </para>
    
    </sect1>
</appendix>

</book>
