/* $Id$ */

/* Copyright(C) 2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or(at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/object.h>
#include <gtkmm/treeiter.h>
#include <gtkmm/widget.h>
#include <gdkmm/window.h>
//#include <gtkmm/cellrenderer.h>
#include <gtkmm/cellrenderertext.h>
#include <gtkmm/cellrendererpixbuf.h>
#include <gtkmm/cellrenderertoggle.h>
#include <gtkmm/treemodel.h>
#include <glibmm/listhandle.h>
_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/object_p.h)


namespace Gtk
{

_CC_INCLUDE(gtk/gtktypebuiltins.h)
_WRAP_ENUM(TreeViewColumnSizing, GtkTreeViewColumnSizing)


namespace TreeViewColumn_CellRendererGeneration
{

#ifndef DOXYGEN_SHOULD_SKIP_THIS
template<class T_ModelColumnType> //e.g. bool or Glib::ustring.
CellRenderer* generate_cellrenderer(bool editable = false)
{
  CellRendererText* pCellRenderer = new CellRendererText(); //the default - template specializations will use other renderers.
  //CellRendererText can render both strings and numerical values.

  pCellRenderer->property_editable() = editable;
  return pCellRenderer;
}

#if !defined(__GNUC__) || __GNUC__ > 2
// gcc 2.95.x fail in TreeView::append_column_editable if the
// following specializations are included
template<>
CellRenderer* generate_cellrenderer<bool>(bool editable);

template<>
CellRenderer* generate_cellrenderer< Glib::RefPtr<Gdk::Pixbuf> >(bool editable);
#endif

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} //anoymous TreeViewColumn_CellRendererGeneration

/** Typedefed as Gtk::TreeView::Column.
 * This is a visible column in a Gtk::TreeView widget. It determines the geometry, type.
 *
 * @ingroup TreeView
*/
class TreeViewColumn : public Gtk::Object
{
  _CLASS_GTKOBJECT(TreeViewColumn, GtkTreeViewColumn, GTK_TREE_VIEW_COLUMN, Gtk::Object, GtkObject)
  _IGNORE(gtk_tree_view_column_set_cell_data_func)
public:
  typedef TreeViewColumn Column;

  _CTOR_DEFAULT()

  explicit TreeViewColumn(const Glib::ustring& title);
  TreeViewColumn(const Glib::ustring& title, CellRenderer& cell);

  /** Create a default view column for the given model column type.
   */
  template<class T_ModelColumnType>
  TreeViewColumn(const Glib::ustring& title, const TreeModelColumn<T_ModelColumnType>& column);

  _WRAP_METHOD(void pack_start(CellRenderer& cell, bool expand = true), gtk_tree_view_column_pack_start)
  _WRAP_METHOD(void pack_end(CellRenderer& cell, bool expand = true), gtk_tree_view_column_pack_end)


  template<class T_ModelColumnType>
  void pack_start(const TreeModelColumn<T_ModelColumnType>& column, bool expand = true);

  template<class T_ModelColumnType>
  void pack_end(const TreeModelColumn<T_ModelColumnType>& column, bool expand = true);

  _WRAP_METHOD(void clear(), gtk_tree_view_column_clear)

  /** Gets the CellRenderer for the column.
    * You should dynamic_cast<> to the expected derived CellRenderer type.
    * This assumes that the TreeViewColumn contains only one CellRenderer.
    */
  CellRenderer* get_first_cell_renderer();

  /** Gets the CellRenderer for the column.
    * You should dynamic_cast<> to the expected derived CellRenderer type.
    * This assumes that the TreeViewColumn contains only one CellRenderer.
    */
  const CellRenderer* get_first_cell_renderer() const;

  _WRAP_METHOD(Glib::ListHandle<CellRenderer*> get_cell_renderers(), gtk_tree_view_column_get_cell_renderers)
  _WRAP_METHOD(Glib::ListHandle<const CellRenderer*> get_cell_renderers() const, gtk_tree_view_column_get_cell_renderers)

  _WRAP_METHOD(void add_attribute(CellRenderer& cell_renderer, const Glib::ustring& attribute, int column),
               gtk_tree_view_column_add_attribute)

  void add_attribute(const Glib::PropertyProxy_Base& property, const TreeModelColumnBase& column);
  _IGNORE(gtk_tree_view_column_set_attributes)

  void set_renderer(Gtk::CellRenderer& renderer, const TreeModelColumnBase& column);

 // _WRAP_METHOD(void set_attributes(CellRenderer& cell_renderer, ...), )

  typedef SigC::Slot2<void, CellRenderer*, const Gtk::TreeModel::iterator&> SlotCellData;

  void set_cell_data_func(CellRenderer& cell_renderer, const SlotCellData& slot);
  void unset_cell_data_func(CellRenderer& cell_renderer);

  _WRAP_METHOD(void clear_attributes(CellRenderer& cell_renderer), gtk_tree_view_column_clear_attributes)
  _WRAP_METHOD(void set_spacing(int spacing), gtk_tree_view_column_set_spacing)
  _WRAP_METHOD(int get_spacing() const, gtk_tree_view_column_get_spacing)
  _WRAP_METHOD(void set_visible(bool visible = true), gtk_tree_view_column_set_visible)
  _WRAP_METHOD(bool get_visible() const, gtk_tree_view_column_get_visible)
  _WRAP_METHOD(void set_resizable(bool resizable = true), gtk_tree_view_column_set_resizable)
  _WRAP_METHOD(bool get_resizable() const, gtk_tree_view_column_get_resizable)
  _WRAP_METHOD(void set_sizing(TreeViewColumnSizing type), gtk_tree_view_column_set_sizing)
  _WRAP_METHOD(TreeViewColumnSizing get_sizing(), gtk_tree_view_column_get_sizing)
  _WRAP_METHOD(int get_width() const, gtk_tree_view_column_get_width)
  _WRAP_METHOD(int get_fixed_width() const, gtk_tree_view_column_get_fixed_width)
  _WRAP_METHOD(void set_fixed_width(int fixed_width), gtk_tree_view_column_set_fixed_width)
  _WRAP_METHOD(void set_min_width(int min_width), gtk_tree_view_column_set_min_width)
  _WRAP_METHOD(int get_min_width() const, gtk_tree_view_column_get_min_width)
  _WRAP_METHOD(void set_max_width(int max_width), gtk_tree_view_column_set_max_width)
  _WRAP_METHOD(int get_max_width() const, gtk_tree_view_column_get_max_width)
  _WRAP_METHOD(void clicked(), gtk_tree_view_column_clicked)

  _WRAP_METHOD(void set_title(const Glib::ustring& title), gtk_tree_view_column_set_title)
  _WRAP_METHOD(Glib::ustring get_title() const, gtk_tree_view_column_get_title)

  _WRAP_METHOD(void set_expand(bool expand = true), gtk_tree_view_column_set_expand)
  _WRAP_METHOD(bool get_expand() const, gtk_tree_view_column_get_expand)

  _WRAP_METHOD(void set_clickable(bool clickable = true), gtk_tree_view_column_set_clickable)
  _WRAP_METHOD(bool get_clickable() const, gtk_tree_view_column_get_clickable)
  _WRAP_METHOD(void set_widget(Gtk::Widget& widget), gtk_tree_view_column_set_widget)
  _WRAP_METHOD(Widget* get_widget(), gtk_tree_view_column_get_widget)
  _WRAP_METHOD(const Widget* get_widget() const, gtk_tree_view_column_get_widget)

  _WRAP_METHOD(void set_alignment(float xalign), gtk_tree_view_column_set_alignment)
  _WRAP_METHOD(void set_alignment(AlignmentEnum xalign), gtk_tree_view_column_set_alignment)

  _WRAP_METHOD(float get_alignment() const, gtk_tree_view_column_get_alignment)
  _WRAP_METHOD(void set_reorderable(bool reorderable = true), gtk_tree_view_column_set_reorderable)
  _WRAP_METHOD(bool get_reorderable() const, gtk_tree_view_column_get_reorderable)

  _WRAP_METHOD(void set_sort_column_id(const TreeModelColumnBase& sort_column_id), gtk_tree_view_column_set_sort_column_id)
  _WRAP_METHOD(void set_sort_column_id(int sort_column_id), gtk_tree_view_column_set_sort_column_id)
  _WRAP_METHOD(int get_sort_column_id() const, gtk_tree_view_column_get_sort_column_id)
  _WRAP_METHOD(void set_sort_indicator(bool setting), gtk_tree_view_column_set_sort_indicator)
  _WRAP_METHOD(bool get_sort_indicator() const, gtk_tree_view_column_get_sort_indicator)
  _WRAP_METHOD(void set_sort_order(SortType order), gtk_tree_view_column_set_sort_order)
  _WRAP_METHOD(SortType get_sort_order() const, gtk_tree_view_column_get_sort_order)


  _WRAP_METHOD(void cell_set_cell_data(const Glib::RefPtr<TreeModel>& tree_model, const TreeModel::iterator& iter, bool is_expander, bool is_expanded), gtk_tree_view_column_cell_set_cell_data)
  _WRAP_METHOD(void cell_get_size(Gdk::Rectangle& cell_area, int& x_offset, int& y_offset, int& width, int& height) const, gtk_tree_view_column_cell_get_size)
  _WRAP_METHOD(bool cell_is_visible() const, gtk_tree_view_column_cell_is_visible)
  _WRAP_METHOD(void focus_cell(CellRenderer& cell), gtk_tree_view_column_focus_cell)

  _WRAP_SIGNAL(void clicked(), "clicked")

  _WRAP_PROPERTY("visible", bool)
  _WRAP_PROPERTY("width", int)
  _WRAP_PROPERTY("sizing", TreeViewColumnSizing)
  _WRAP_PROPERTY("fixed-width", int)
  _WRAP_PROPERTY("min-width", int)
  _WRAP_PROPERTY("max-width", int)
  _WRAP_PROPERTY("title", Glib::ustring)
  _WRAP_PROPERTY("expand", bool)
  _WRAP_PROPERTY("clickable", bool)
  _WRAP_PROPERTY("widget", Widget*)
  _WRAP_PROPERTY("alignment", float)
  _WRAP_PROPERTY("reorderable", bool)
  _WRAP_PROPERTY("sort-indicator", bool)
  _WRAP_PROPERTY("sort-order", SortType)

#ifndef DOXYGEN_SHOULD_SKIP_THIS
private:
  // Only necessary because of the templated ctor, see below.
  static const Glib::Class& class_init_();
#endif //DOXYGEN_SHOULD_SKIP_THIS
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

template<class T_ModelColumnType>
void TreeViewColumn::pack_start(const TreeModelColumn<T_ModelColumnType>& column, bool expand)
{
  //Generate appropriate Renderer for the column:
  CellRenderer* pCellRenderer = manage( TreeViewColumn_CellRendererGeneration::generate_cellrenderer<T_ModelColumnType>() );

  //Use the renderer:
  pack_start(*pCellRenderer, expand);
  set_renderer(*pCellRenderer, column);
}

template<class T_ModelColumnType>
void TreeViewColumn::pack_end(const TreeModelColumn<T_ModelColumnType>& column, bool expand)
{
  //Generate appropriate Renderer for the column:
  CellRenderer* pCellRenderer= manage( TreeViewColumn_CellRendererGeneration::generate_cellrenderer<T_ModelColumnType>() );

  //Use the renderer:
  pack_end(*pCellRenderer, expand);
  set_renderer(*pCellRenderer, column);
}


template <class T_ModelColumnType>
TreeViewColumn::TreeViewColumn(const Glib::ustring& title,
                               const TreeModelColumn<T_ModelColumnType>& column)
:
  Glib::ObjectBase(0), // not (yet) a custom class
  Gtk::Object(Glib::ConstructParams(class_init_(), "title", title.c_str(), (char*) 0))
{
  pack_start(column, true /* expand */);
}



#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Gtk

