/* $Id$ */

/* Copyright (C) 2003 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/widget.h>
#include <gtkmm/treemodel.h>
 
_DEFS(gtkmm,gtk)
_PINCLUDE(glibmm/private/object_p.h)


namespace Gtk
{

class Entry;

class EntryCompletion : public Glib::Object
{
  _CLASS_GOBJECT(EntryCompletion, GtkEntryCompletion, GTK_ENTRY_COMPLETION, Glib::Object, GObject)

protected:
  _CTOR_DEFAULT()

public:
  _WRAP_CREATE()

  //Careful, this actually returns a GtkWidget*, so it might not always be a GtkEntry in future GTK+ versions.
  _WRAP_METHOD(Entry* get_entry(), gtk_entry_completion_get_entry)
  _WRAP_METHOD(const Entry* get_entry() const, gtk_entry_completion_get_entry)

  _WRAP_METHOD(void set_model(const Glib::RefPtr<TreeModel>& model), gtk_entry_completion_set_model)
  _WRAP_METHOD(Glib::RefPtr<TreeModel> get_model(), gtk_entry_completion_get_model, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const TreeModel> get_model() const, gtk_entry_completion_get_model, refreturn)

  /// For example, bool on_match(const Glib::ustring& key, const TreeModel::const_iterator& iter);
  typedef sigc::slot<bool, const Glib::ustring&, const TreeModel::const_iterator&> SlotMatch;
  
  void set_match_func(const SlotMatch& slot);
  _IGNORE(gtk_entry_completion_set_match_func)
  
  _WRAP_METHOD(void set_minimum_key_length(int length), gtk_entry_completion_set_minimum_key_length)
  _WRAP_METHOD(int get_minimum_key_length() const, gtk_entry_completion_get_minimum_key_length)
  _WRAP_METHOD(void complete(), gtk_entry_completion_complete)

  _WRAP_METHOD(void insert_prefix(), gtk_entry_completion_insert_prefix)

  //We reordered the parameters, compared to the C version, so that we can have method overloads without the index.

  // TODO: We would really like an insert() which before-inserts an iterator, like ListStore::insert(),
  // but there is no EntryCompletion::insert_before() for us to use.
  void insert_action_text(const Glib::ustring& text, int index);
  void prepend_action_text(const Glib::ustring& text);
  //TODO: Add append_action_text() somehow? It would be slow if we count the children each time. murrayc.
  _IGNORE(gtk_entry_completion_insert_action_text)
  void insert_action_markup(const Glib::ustring& markup, int index);
  void prepend_action_markup(const Glib::ustring& markup);
  _IGNORE(gtk_entry_completion_insert_action_markup)

  //TODO: Change default - it would be nicer to delete the last action instead of the first.
  _WRAP_METHOD(void delete_action(int index = 0), gtk_entry_completion_delete_action)

  _WRAP_METHOD(void set_inline_completion(bool inline_completion = true), gtk_entry_completion_set_inline_completion)
  _WRAP_METHOD(bool get_inline_completion() const, gtk_entry_completion_get_inline_completion)
  _WRAP_METHOD(void set_popup_completion(bool popup_completion = true), gtk_entry_completion_set_popup_completion)
  _WRAP_METHOD(bool get_popup_completion() const, gtk_entry_completion_get_popup_completion)

  _WRAP_METHOD(void set_text_column(const TreeModelColumnBase& column), gtk_entry_completion_set_text_column)
  _WRAP_METHOD(void set_text_column(int column), gtk_entry_completion_set_text_column)
  _WRAP_METHOD(int get_text_column(), gtk_entry_completion_get_text_column)

  //TODO: The C++ iterator needs to know about the model. We need some custom stuff here.
  //but I think I've done it elsewhere. murrayc:
  //_WRAP_SIGNAL(bool match_selected(const TreeModel::iterator& iter), match_selected)
  _WRAP_SIGNAL(void action_activated(int index), action_activated)

  //We completely hand-code this signal because we want to change how the parameters are wrapped,
  //because we need both the iter and the model to make the C++ iter.
  _IGNORE_SIGNAL(match_selected)

  /**
   * @par Prototype:
   * <tt>bool %match_selected(const TreeModel::iterator& iter)</tt>
   */
  Glib::SignalProxy1< bool, const TreeModel::iterator& > signal_match_selected();

  #m4begin
dnl// Hook in custom callback.
dnl// It will use the callback.
dnl
  _PUSH(SECTION_PCC_CLASS_INIT_DEFAULT_SIGNAL_HANDLERS)
    klass->match_selected = &match_selected_callback_custom;
  _SECTION(SECTION_PH_DEFAULT_SIGNAL_HANDLERS)
    static gboolean match_selected_callback_custom(GtkEntryCompletion* self, GtkTreeModel* c_model, GtkTreeIter* c_iter);
  _POP()
#m4end

protected:

  //Default Signal Handler:
  virtual bool on_match_selected(const TreeModel::iterator& iter);


             
};

} // namespace Gtk

