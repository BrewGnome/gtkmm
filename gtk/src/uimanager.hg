/* $Id$ */

/* Copyright (C) 2003 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/widget.h>
#include <gtkmm/action.h>
#include <gtkmm/actiongroup.h>
#include <gtkmm/uimanager.h>
 
_DEFS(gtkmm,gtk)
_PINCLUDE(glibmm/private/object_p.h)


namespace Gtk
{

_WRAP_ENUM(UIManagerItemType, GtkUIManagerItemType)

class UIManager : public Glib::Object
{
  _CLASS_GOBJECT(UIManager, GtkUIManager, GTK_UI_MANAGER, Glib::Object, GObject)
protected:
  _CTOR_DEFAULT()

public:
  _WRAP_CREATE()

  _WRAP_METHOD(void set_add_tearoffs(bool add_tearoffs = true), gtk_ui_manager_set_add_tearoffs)
  _WRAP_METHOD(bool get_add_tearoffs() const, gtk_ui_manager_get_add_tearoffs)
  _WRAP_METHOD(void insert_action_group(const Glib::RefPtr<ActionGroup>& action_group, int pos = 0), gtk_ui_manager_insert_action_group)
  _WRAP_METHOD(void remove_action_group(const Glib::RefPtr<ActionGroup>& action_group), gtk_ui_manager_remove_action_group)

#m4 dnl // Override the conversion in convert_gtk.m4, because the default behaviour is wrong for this method:
#m4 _CONVERSION(`GList*', `Glib::ListHandle Glib::RefPtr<ActionGroup> >', __FL2H_NONE)
#m4 _CONVERSION(`GList*', `Glib::ListHandle< Glib::RefPtr<ActionGroup> >', __FL2H_NONE)

  _WRAP_METHOD(Glib::ListHandle< Glib::RefPtr<ActionGroup> > get_action_groups(), gtk_ui_manager_get_action_groups)
  _WRAP_METHOD(Glib::ListHandle< Glib::RefPtr<const ActionGroup> > get_action_groups() const, gtk_ui_manager_get_action_groups)
  
  _WRAP_METHOD(Glib::RefPtr<AccelGroup> get_accel_group(), gtk_ui_manager_get_accel_group, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const AccelGroup> get_accel_group() const, gtk_ui_manager_get_accel_group, refreturn, constversion)
  _WRAP_METHOD(Widget* get_widget(const Glib::ustring& path), gtk_ui_manager_get_widget)
  _WRAP_METHOD(const Widget* get_widget(const Glib::ustring& path) const, gtk_ui_manager_get_widget, constversion)

  _WRAP_METHOD(Glib::SListHandle<Widget*> get_toplevels(UIManagerItemType types), gtk_ui_manager_get_toplevels)
  _WRAP_METHOD(Glib::SListHandle<const Widget*> get_toplevels(UIManagerItemType types) const, gtk_ui_manager_get_toplevels)
                 
  _WRAP_METHOD(Glib::RefPtr<Action> get_action(const Glib::ustring& path), gtk_ui_manager_get_action, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Action> get_action(const Glib::ustring& path) const, gtk_ui_manager_get_action, refreturn, constversion)

  typedef guint ui_merge_id;
    
  /** Parses a string containing a UI definition and
   * merges it with the current contents. An enclosing &lt;ui&gt;
   * element is added if it is missing.
   *
   * @param buffer the string to parse
   * @result  The merge id for the merged UI. The merge id can be used to unmerge the UI with remove_ui(). If an error occurred, the return value is 0.
   * @throws exception
   * Since: 2.4
   */ 
  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  ui_merge_id add_ui_from_string(const Glib::ustring& buffer);
  #else
  ui_merge_id add_ui_from_string(const Glib::ustring& buffer, std::auto_ptr<Glib::Error>& error);
  #endif //GLIBMM_EXCEPTIONS_ENABLED
  _IGNORE(gtk_ui_manager_add_ui_from_string)
  _WRAP_METHOD(ui_merge_id add_ui_from_file(const Glib::ustring& filename), gtk_ui_manager_add_ui_from_file, errthrow)

//TODO: Is top=true a good default?

  _WRAP_METHOD(void add_ui(ui_merge_id merge_id, const Glib::ustring& path, const Glib::ustring& name, const Glib::ustring& action, UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true), gtk_ui_manager_add_ui)

  /** Adds a separator UI element to the current contents.
   *
   * If @a type  is Gtk::UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
   * separator if such an element can be inserted at the place determined by
   *  @a path . Otherwise @a type  must indicate an element that can be inserted at
   * the place determined by @a path.
   *
   * @see add_ui().
   *
   * Since: 2.4
   * @param merge_id The merge id for the merged UI, see gtk_ui_manager_new_merge_id().
   * @param path A path.
   * @param name The name for the added UI element.
   * @param type The type of UI element to add.
   * @param top If <tt>true</tt>, the UI element is added before its siblings, otherwise it
   * is added after its siblings.
   */
  void add_ui_separator(ui_merge_id merge_id, const Glib::ustring& path, const Glib::ustring& name = "", UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true);
  
  _WRAP_METHOD(void remove_ui(ui_merge_id merge_id), gtk_ui_manager_remove_ui)
  _WRAP_METHOD(Glib::ustring get_ui() const, gtk_ui_manager_get_ui)
  _WRAP_METHOD(void ensure_update(), gtk_ui_manager_ensure_update)
  _WRAP_METHOD(ui_merge_id new_merge_id(), gtk_ui_manager_new_merge_id)

  /** The add_widget signal is emitted for each generated menubar and toolbar.
   * It is not emitted for generated popup menus, which can be obtained by 
   * get_widget().
   * 
   * @param widget the added widget
   */
  _WRAP_SIGNAL(void add_widget(Widget* widget), add_widget)
  
  /** The "actions-changed" signal is emitted whenever the set of actions
   * changes.
   */
  _WRAP_SIGNAL(void actions_changed(), actions_changed)
  
  /** The connect_proxy signal is emitted after connecting a proxy to 
   * an action in the group. 
   *
   * This is intended for simple customizations for which a custom action
   * class would be too clumsy, e.g. showing tooltips for menuitems in the
   * statusbar.
   *
   * @param action the action
   * @param widget the proxy
   */
  _WRAP_SIGNAL(void connect_proxy(const Glib::RefPtr<Action>& action, Widget* widget), connect_proxy, no_default_handler)
  
  /** The disconnect_proxy signal is emitted after disconnecting a proxy 
   * from an action in the group. 
   *
   * @param action the action
   * @param widget the proxy
   */
  _WRAP_SIGNAL(void disconnect_proxy(const Glib::RefPtr<Action>& action, Widget* widget), disconnect_proxy, no_default_handler)
  
  /** The pre_activate signal is emitted just before the @a action
   * is activated.
   *
   * This is intended for applications to get notification
   * just before any action is activated.
   *
   * @param action the action
   */
  _WRAP_SIGNAL(void pre_activate(const Glib::RefPtr<Action>& action), pre_activate, no_default_handler)
  
  /** The post_activate signal is emitted just after the @a action
   * is activated.
   *
   * This is intended for applications to get notification
   * just after any action is activated.
   *
   * @param action the action
   */
  _WRAP_SIGNAL(void post_activate(const Glib::RefPtr<Action>& action), post_activate, no_default_handler)

  _WRAP_PROPERTY("add_tearoffs", bool)
  _WRAP_PROPERTY("ui", Glib::ustring)
             
};

} // namespace Gtk

