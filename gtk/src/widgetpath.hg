/* Copyright 2010 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/enums.h>

_DEFS(gtkmm,gtk)

namespace Gtk
{

/** TODO
 *
 * @newin{3,0}
 */
class WidgetPath
{
  _CLASS_BOXEDTYPE(WidgetPath, GtkWidgetPath, gtk_widget_path_new, gtk_widget_path_copy, gtk_widget_path_free)
  _IGNORE(gtk_widget_path_new, gtk_widget_path_copy, gtk_widget_path_free)
public:

  _WRAP_METHOD(int path_length() const, gtk_widget_path_length)

  _WRAP_METHOD(int path_append_type(GType type), gtk_widget_path_append_type)
  _WRAP_METHOD(void prepend_type(GType type), gtk_widget_path_prepend_type)

  _WRAP_METHOD(GType get_widget_type(int pos) const, gtk_widget_path_iter_get_widget_type)
  _WRAP_METHOD(void set_widget_type(int pos, GType type), gtk_widget_path_iter_set_widget_type)

  _WRAP_METHOD(Glib::ustring iter_get_name(int pos) const, gtk_widget_path_iter_get_name)
  _WRAP_METHOD(void iter_set_name(int pos, const Glib::ustring& name), gtk_widget_path_iter_set_name)
  _WRAP_METHOD(bool iter_has_name(int pos, const Glib::ustring& name) const, gtk_widget_path_iter_has_name)
  //TODO: _WRAP_METHOD(bool iter_has_qname(int pos, GQuark qname) const, gtk_widget_path_iter_has_qname)

  _WRAP_METHOD(void iter_add_class(int pos, const Glib::ustring& name), gtk_widget_path_iter_add_class)
  _WRAP_METHOD(void iter_remove_class(int pos, const Glib::ustring& name), gtk_widget_path_iter_remove_class)
  _WRAP_METHOD(void iter_clear_classes(int pos), gtk_widget_path_iter_clear_classes)
  //TODO: _WRAP_METHOD(GSList * gtk_widget_path_iter_list_classes(const GtkWidgetPath *path, int pos), gtk_widget_path_iter_list_classes)
  _WRAP_METHOD(bool iter_has_class(int pos, const Glib::ustring& name) const, gtk_widget_path_iter_has_class)
  //TODOL_WRAP_METHOD(bool iter_has_qclass(int pos, GQuark qname) const, gtk_widget_path_iter_has_qclass)

  _WRAP_METHOD(void iter_add_region(int  pos, const Glib::ustring& name,  RegionFlags flags), gtk_widget_path_iter_add_region)
  _WRAP_METHOD(void iter_remove_region(int pos, const Glib::ustring& name), gtk_widget_path_iter_remove_region)
  _WRAP_METHOD(void iter_clear_regions(int pos), gtk_widget_path_iter_clear_regions)

  //TODO: _WRAP_METHOD(GSList* iter_list_regions(int pos), gtk_widget_path_iter_list_regions)

  _WRAP_METHOD(bool iter_has_region(int pos, const Glib::ustring& name, RegionFlags& flags) const, gtk_widget_path_iter_has_region)
  //TODO: _WRAP_METHOD(bool iter_has_qregion(int pos, GQuark qname,  RegionFlags& flags), gtk_widget_path_iter_has_qregion)

  _WRAP_METHOD(GType get_widget_type() const,  gtk_widget_path_get_widget_type)

  _WRAP_METHOD(bool is_type(GType type) const, gtk_widget_path_is_type)
  _WRAP_METHOD(bool has_parent(GType type) const, gtk_widget_path_has_parent)

};

} /* namespace Gtk */


