/* $Id$ */

/* Copyright (C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/helperlist.h>
#include <gtkmm/container.h>
#include <gtkmm/stockid.h>
#include <gtk/gtktoolbar.h> /* Needed for GtkToolbarChild */

_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/container_p.h)


namespace Gtk
{

_CC_INCLUDE(gtk/gtktypebuiltins.h)
_WRAP_ENUM(ToolbarChildType, GtkToolbarChildType)


/** @defgroup Toolbars Toolbar classes
 */

/* toolbar is a bit of a factory.  We will
represent this by making a virtual list called
tools.  Tools iterates through the children
of list.  It looks like list<Toolbar_Helpers::Tool*>
but inserts Toolbar::Element.  Elements 
are a factory for spaces, widget, buttons, toggle
buttons and radio buttons. 

The name "icon" in the gtk+ interface is very
misleading, it is really a button content
not a pixmap.  We will rename it to "content".

Confused?  Okay go read the interface.
*/
class Toolbar;

class RadioButtonGroup;

namespace Toolbar_Helpers
{
/*********************************************************************
***** Elem classes (This should be an easy and cool interface) 
*********************************************************************/

typedef SigC::Slot0<void> Callback0;

// Tool is the output class (very thin wrapper)
class Tool : private GtkToolbarChild
{
private:
  Tool(const Tool&);
  Tool& operator=(const Tool&);

public:
  ToolbarChildType get_type() const;
  Widget* get_widget()  const;
  Widget* get_content() const;
  Label*  get_label()   const;

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  friend class Dummy_; // silence the compiler (Child has only private ctors)
#endif
};

// Element is the input class
class ToolList;
class Element
{
friend class ToolList;
protected:
  ToolbarChildType    type_;
  Widget*             widget_;
  Glib::ustring       text_;
  bool                has_text_;
  StockID             stock_id_;
  Glib::ustring       tooltip_text_;
  Glib::ustring       tooltip_private_text_;
  Widget*             content_; // This does not need to be a pixmap.
  Callback0           callback_;
  RadioButtonGroup* group_;

private:
  Element& operator=(const Element&);

protected:
  // some fields are mutually exclusive
  Element(ToolbarChildType      type,
          Widget*               widget,
          const Glib::ustring&  text,
          bool                  has_text,
          const Gtk::StockID&   stock_id,
          const Glib::ustring&  tooltip_text,
          const Glib::ustring&  tooltip_private_text,
          Widget*               content,
          const Callback0&      callback);

public:
  Element(const Element& other);

  Element(Widget& widget,
          const Glib::ustring& tooltip_text         = Glib::ustring(),
          const Glib::ustring& tooltip_private_text = Glib::ustring());
};

/** @ingroup Toolbars
 */
struct Space : public Element
{
  Space();
};

/** @ingroup Toolbars
 */
struct StockElem : public Element
{
  StockElem(const Gtk::StockID&  stock_id,
            const Callback0&     callback,
            const Glib::ustring& tooltip_text         = Glib::ustring(),
            const Glib::ustring& tooltip_private_text = Glib::ustring());
};

typedef Element WidgetElem;

// Order here is different than gtk+, watch yourself
// Each button set has 3 forms i
//   with a Glib::ustring and content
//   with a Glib::ustring
//   with content (ie Pixmap, images, etc)
//
/** @ingroup Toolbars
 */
struct ButtonElem : public Element
{
  ButtonElem(const Glib::ustring& text,
             Widget&         content,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());

  ButtonElem(Widget&         content,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());

  ButtonElem(const Glib::ustring& text,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());
};

/** @ingroup Toolbars
 */
struct ToggleElem : public Element
{
  ToggleElem(const Glib::ustring& text,
             Widget&         content,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());

  ToggleElem(Widget&         content,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());

  ToggleElem(const Glib::ustring& text,
             const Callback0&     callback,
             const Glib::ustring& tooltip_text         = Glib::ustring(),
             const Glib::ustring& tooltip_private_text = Glib::ustring());
};

/** @ingroup Toolbars
 */
struct RadioElem : public Element
{
  RadioElem(RadioButtonGroup& group,
            const Glib::ustring& text,
            Widget&         content,
            const Callback0&     callback             = Callback0(),
            const Glib::ustring& tooltip_text         = Glib::ustring(),
            const Glib::ustring& tooltip_private_text = Glib::ustring());

  RadioElem(RadioButtonGroup& group,
            Widget&         content,
            const Callback0&     callback             = Callback0(),
            const Glib::ustring& tooltip_text         = Glib::ustring(),
            const Glib::ustring& tooltip_private_text = Glib::ustring());

  RadioElem(RadioButtonGroup& group,
            const Glib::ustring& text,
            const Callback0&     callback             = Callback0(),
            const Glib::ustring& tooltip_text         = Glib::ustring(),
            const Glib::ustring& tooltip_private_text = Glib::ustring());
};

/*********************************************************************
***** List properties
*********************************************************************/
#m4 include(list.m4)
  GP_LIST(ToolList,Toolbar,GtkToolbar,Tool,children)
  //The standard iterator, instead of List_Cpp_Iterator,
  //only works because Child is derived from GtkToolbarChild.

  virtual void remove(Widget& widget);
  GP_LIST_FIND(get_widget)
  GP_LIST_END()

} /* namespace Toolbar_Helpers */


/** Bars of buttons and other widgets.
 * The STL-style container is available via the tools() method.
 * @ingroup Widgets
 * @ingroup Containers
 * @ingroup Toolbars
 */
class Toolbar : public Container
{
  _CLASS_GTKOBJECT(Toolbar,GtkToolbar,GTK_TOOLBAR,Gtk::Container,GtkContainer)
public:
  typedef Toolbar_Helpers::ToolList ToolList;

  _CTOR_DEFAULT


/* Style methods */
  _WRAP_METHOD(void set_orientation(Orientation orientation), gtk_toolbar_set_orientation)
  _WRAP_METHOD(Orientation get_orientation() const, gtk_toolbar_get_orientation)

  _WRAP_METHOD(void set_toolbar_style(ToolbarStyle style), gtk_toolbar_set_style)
  _WRAP_METHOD(ToolbarStyle get_toolbar_style() const, gtk_toolbar_get_style)

  _WRAP_METHOD(void set_tooltips(bool enable = true), gtk_toolbar_set_tooltips)
  _WRAP_METHOD(bool get_tooltips() const, gtk_toolbar_get_tooltips)

  _WRAP_METHOD(void set_icon_size(IconSize icon_size), gtk_toolbar_set_icon_size)
  _WRAP_METHOD(IconSize get_icon_size() const, gtk_toolbar_get_icon_size)

  _WRAP_METHOD(void unset_toolbar_style(), gtk_toolbar_unset_style)
  _WRAP_METHOD(void unset_icon_size(), gtk_toolbar_unset_icon_size)

  _WRAP_SIGNAL(void orientation_changed(Orientation orientation), "orientation_changed")
  _WRAP_SIGNAL(void toolbar_style_changed(ToolbarStyle style),"style_changed")

  ///STL-style container.
  ToolList& tools();
  
  ///STL-style container.
  const ToolList& tools() const;


  typedef Toolbar_Helpers::Callback0 Callback0;
  Gtk::Widget* append_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Gtk::Widget& icon, Callback0 slot);
  Gtk::Widget* append_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Callback0 slot);
  _IGNORE(gtk_toolbar_append_item)
    
  Gtk::Widget* prepend_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Gtk::Widget& icon, Callback0 slot);
  Gtk::Widget* prepend_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Callback0 slot);
  _IGNORE(gtk_toolbar_prepend_item)
    
  Gtk::Widget* insert_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Gtk::Widget& icon, Callback0 slot,
    int position);
  Gtk::Widget* insert_item(const Glib::ustring& text, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Callback0 slot,
    int position);
  _IGNORE(gtk_toolbar_insert_item)

  Gtk::Widget* insert_stock(const Gtk::StockID& stock_id, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text,
    Callback0 slot,
    int position);
  _IGNORE(gtk_toolbar_insert_stock)


  _WRAP_METHOD(void append_space(), gtk_toolbar_append_space)
  _WRAP_METHOD(void prepend_space(), gtk_toolbar_prepend_space)
  _WRAP_METHOD(void insert_space(int position), gtk_toolbar_insert_space)
  _WRAP_METHOD(void remove_space(int position), gtk_toolbar_remove_space)

  _WRAP_METHOD(void append_widget(Gtk::Widget& widget, const Glib::ustring& tooltip_text = Glib::ustring(), const Glib::ustring& tooltip_private_text = Glib::ustring()), gtk_toolbar_append_widget)
  _WRAP_METHOD(void prepend_widget(Gtk::Widget& widget, const Glib::ustring& tooltip_text = Glib::ustring(), const Glib::ustring& tooltip_private_text = Glib::ustring()), gtk_toolbar_prepend_widget)
  _WRAP_METHOD(void insert_widget(Gtk::Widget& widget, const Glib::ustring& tooltip_text, const Glib::ustring& tooltip_private_text, int position), gtk_toolbar_insert_widget)

  //Let's not wrap gtk_toolbar_*_element(), because they don't do anything extra, and it's an unclear API.
  _IGNORE(gtk_toolbar_append_element, gtk_toolbar_prepend_element, gtk_toolbar_insert_element)

  _WRAP_PROPERTY("orientation", Orientation)
  _WRAP_PROPERTY("toolbar_style", ToolbarStyle)

protected:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  mutable ToolList tools_proxy_;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */
};

} // namespace Gtk

