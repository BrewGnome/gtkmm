// -*- c++ -*-
/* $Id$ */

/* Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/adjustment.h>
#include <gtkmm/window.h>
#include <gtkmm/accelgroup.h>
#include <gtkmm/settings.h>
#include <gtkmm/style.h>
#include <gtkmm/container.h>
#include <gtkmm/selectiondata_private.h>
#include <gtk/gtkdnd.h>
#include <gtk/gtkselection.h>
#include <gtk/gtkwidget.h>
#include <gtk/gtkcontainer.h>
#include <gtk/gtkmain.h>


namespace Gtk
{

Widget::~Widget()
{}

bool Widget::intersect(const Gdk::Rectangle& area) const
{
  return gtk_widget_intersect(
      const_cast<GtkWidget*>(gobj()), const_cast<GdkRectangle*>(area.gobj()), 0);
}

void Widget::unset_name()
{
  gtk_widget_set_name(gobj(), 0);
}

void Widget::unset_composite_name()
{
  gtk_widget_set_composite_name(gobj(), 0);
}

void Widget::realize_if_needed()
{
  if(!is_realized())
    realize();
}

void Widget::add_modal_grab()
{
  gtk_grab_add(gobj());
}

void Widget::remove_modal_grab()
{
  gtk_grab_remove(gobj());
}

Widget* Widget::get_current_modal_grab()
{
  return Glib::wrap(gtk_grab_get_current());
}

void Widget::path(Glib::ustring& path_arg, Glib::ustring& path_reversed)
{
  guint path_length = 0;
  Glib::ScopedPtr<gchar> path_ptr;
  Glib::ScopedPtr<gchar> rpath_ptr;

  gtk_widget_path(gobj(), &path_length, path_ptr.addr(), rpath_ptr.addr());

  path_arg.assign(path_ptr.get(), path_ptr.get() + path_length);
  path_reversed.assign(rpath_ptr.get(), rpath_ptr.get() + path_length);
}

void Widget::class_path(Glib::ustring& path_arg, Glib::ustring& path_reversed)
{
  guint path_length = 0;
  Glib::ScopedPtr<gchar> path_ptr;
  Glib::ScopedPtr<gchar> rpath_ptr;

  gtk_widget_class_path(gobj(), &path_length, path_ptr.addr(), rpath_ptr.addr());

  path_arg.assign(path_ptr.get(), path_ptr.get() + path_length);
  path_reversed.assign(rpath_ptr.get(), rpath_ptr.get() + path_length);
}

void Widget::modify_bg_pixmap(StateType state, const Glib::ustring& pixmap_name)
{
  const Glib::RefPtr<RcStyle> modifier_style = get_modifier_style();
  modifier_style->set_bg_pixmap_name(state, pixmap_name);
  modify_style(modifier_style);
}

void Widget::unset_fg(StateType state)
{
  gtk_widget_modify_fg(gobj(), static_cast<GtkStateType>(state), 0);
}

void Widget::unset_bg(StateType state)
{
  gtk_widget_modify_bg(gobj(), static_cast<GtkStateType>(state), 0);
}

void Widget::unset_text(StateType state)
{
  gtk_widget_modify_text(gobj(), static_cast<GtkStateType>(state), 0);
}

void Widget::unset_base(StateType state)
{
  gtk_widget_modify_base(gobj(), static_cast<GtkStateType>(state), 0);
}

void Widget::unset_font()
{
  gtk_widget_modify_font(gobj(), 0);
}

bool Widget::is_toplevel() const
  { return GTK_WIDGET_TOPLEVEL(gobj()); }

bool Widget::has_no_window() const
  { return GTK_WIDGET_NO_WINDOW(gobj()); }

bool Widget::is_realized() const
  { return GTK_WIDGET_REALIZED(gobj()); }

bool Widget::is_mapped() const
  { return GTK_WIDGET_MAPPED(gobj()); }

bool Widget::is_visible() const
  { return GTK_WIDGET_VISIBLE(gobj()); }

bool Widget::is_drawable() const
  { return GTK_WIDGET_DRAWABLE(gobj()); }

bool Widget::sensitive() const
  { return GTK_WIDGET_SENSITIVE(gobj()); }

bool Widget::parent_sensitive() const
  { return GTK_WIDGET_PARENT_SENSITIVE(gobj()); }

bool Widget::is_sensitive() const
  { return GTK_WIDGET_IS_SENSITIVE(gobj()); }

bool Widget::can_focus() const
  { return GTK_WIDGET_CAN_FOCUS(gobj()); }

bool Widget::has_focus() const
  { return GTK_WIDGET_HAS_FOCUS(gobj()); }

bool Widget::can_default() const
  { return GTK_WIDGET_CAN_DEFAULT(gobj()); }

bool Widget::has_default() const
  { return GTK_WIDGET_HAS_DEFAULT(gobj()); }

bool Widget::has_grab() const
  { return GTK_WIDGET_HAS_GRAB(gobj()); }

bool Widget::rc_style() const
  { return GTK_WIDGET_RC_STYLE(gobj()); }

bool Widget::is_composite_child() const
  { return GTK_WIDGET_COMPOSITE_CHILD(gobj()); }

bool Widget::app_paintable() const
  { return GTK_WIDGET_APP_PAINTABLE(gobj()); }

bool Widget::receives_default() const
  { return GTK_WIDGET_RECEIVES_DEFAULT(gobj()); }

bool Widget::double_buffered() const
  { return GTK_WIDGET_DOUBLE_BUFFERED(gobj()); }

WidgetFlags Widget::get_flags() const
  { return static_cast<WidgetFlags>(GTK_WIDGET_FLAGS(gobj())); }

void Widget::set_flags(WidgetFlags flags)
  { GTK_WIDGET_SET_FLAGS(gobj(), static_cast<guint32>(flags)); }

void Widget::unset_flags(WidgetFlags flags)
  { GTK_WIDGET_UNSET_FLAGS(gobj(), static_cast<guint32>(flags)); }

int Widget::get_width() const
  { return gobj()->allocation.width; }

int Widget::get_height() const
  { return gobj()->allocation.height; }


void Widget::drag_dest_set(DestDefaults flags, Gdk::DragAction actions)
{
  gtk_drag_dest_set(gobj(), (GtkDestDefaults)flags, 0, 0, (GdkDragAction)actions);
}

void Widget::drag_dest_set(const ArrayHandle_TargetEntry& targets,
                           DestDefaults flags, Gdk::DragAction actions)
{
  // I've used Gdk::ACTION_COPY as the default, because Gdk::ACTION_DEFAULT means that
  // it's never a drag destination, so it would seem like this method didn't work. murrayc.
  gtk_drag_dest_set(
      gobj(), (GtkDestDefaults)flags,
      targets.data(), targets.size(), (GdkDragAction)actions);
}

void Widget::drag_source_set(const ArrayHandle_TargetEntry& targets,
                             Gdk::ModifierType start_button_mask, Gdk::DragAction actions)
{
  // I've used Gdk::MODIFIER_MASK as the default, because it seems
  // to mean 'whatever is possible in the context'. murrayc.
  gtk_drag_source_set(
      gobj(), (GdkModifierType)start_button_mask,
      targets.data(), targets.size(), (GdkDragAction)actions);
}

Widget* Widget::drag_get_source_widget(const Glib::RefPtr<Gdk::DragContext>& context) //static
{
  return Glib::wrap( gtk_drag_get_source_widget(Glib::unwrap(context)) );
}

void Widget::drag_set_as_icon(const Glib::RefPtr<Gdk::DragContext>& context, int hot_x, int hot_y)
{
  gtk_drag_set_icon_widget(Glib::unwrap(context), gobj(), hot_x, hot_y);
}

void Widget_Class::hierarchy_changed_callback_custom(GtkWidget* self, GtkWidget* p0)
{
  //GTKMM_LIFECYCLE
  //Don't call wrap() on a GTK+ instance whose gtkmm instance has been deleted - just call the original C callback.
  bool gtkmm_child_already_deleted = Glib::_gobject_cppinstance_already_deleted((GObject*)p0);

  if(!gtkmm_child_already_deleted)
  {
    //Call the regular, generated callback:
    Widget_Class::hierarchy_changed_callback(self, p0);
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    //Call the original underlying C function:
    if(base && base->hierarchy_changed)
      (*base->hierarchy_changed)(self, p0);
  }
}

void Widget_Class::parent_set_callback_custom(GtkWidget* self, GtkWidget* p0)
{
  //GTKMM_LIFECYCLE
  //Don't call wrap() on a GTK+ instance whose gtkmm instance has been deleted - just call the original C callback.
  bool gtkmm_p0_already_deleted = Glib::_gobject_cppinstance_already_deleted((GObject*)p0);

  if(!gtkmm_p0_already_deleted)
  {
    //Call the regular, generated callback:
    Widget_Class::parent_set_callback(self, p0);
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    //Call the original underlying C function:
    if(base && base->parent_set)
      (*base->parent_set)(self, p0);
  }
}

void Widget_Class::dispose_vfunc_callback(GObject* self)
{
  Widget *const obj = dynamic_cast<Widget*>(
      Glib::ObjectBase::_get_current_wrapper(self));

  // This function might be invoked recursively because we're triggering
  // several signal emissions, particularly signal_hide().  Therefore we
  // have to test for cpp_destruction_in_progress_ at this point.

  if(obj && !obj->cpp_destruction_in_progress_)
  {
    GtkWidget *const pWidget = obj->gobj();
    g_return_if_fail(pWidget == GTK_WIDGET(self));

    // Abort dispose if the widget isn't managed, in order to prevent
    // the nasty self-destroying behaviour of GTK+.  This applies to:
    //
    // - GtkWindow, if it received "delete_event"
    // - GtkDialog, which destroys on "response" by default
    // - any widget inside a GtkContainer on gtk_container_destroy()

    if(obj->referenced_)
    {
      // GTKMM_LIFECYCLE
      // Remove the widget from its parent container so that it
      // won't be destroyed later by gtk_container_destroy().
      if(pWidget->parent)
      {
        // Normally, we would have to ref the child widget because
        // gtk_container_remove() unrefs it.  But since we only remove
        // non-managed objects here, the container just releases the
        // reference it has acquired before in gtk_container_add().

        gtk_container_remove(GTK_CONTAINER(pWidget->parent), pWidget);
      }

      // Now hide the widget.  The C++ object must _not_ be accessed anymore
      // after this call, because a signal_hide() handler might delete it.
      gtk_widget_hide(pWidget);

      // GTKMM_LIFECYCLE
      return; // Prevent calling of normal C dispose vfunc (see below)
    }

    // Always hide widgets on gtk_object_destroy(), regardless of whether
    // the widget is managed or not.  This is done for consistency so that
    // connecting to signal_hide() is guaranteed to work.
    gtk_widget_hide(pWidget);
  }

  GObjectClass *const base = static_cast<GObjectClass*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)));

  if(base->dispose)
    (*base->dispose)(self);
}

} // namespace Gtk

