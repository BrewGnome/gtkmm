// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GTKMM_WRAPBOX_H
#define _GTKMM_WRAPBOX_H


#include <glibmm.h>

/* Copyright (C) 2010 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/container.h>
#include <gtkmm/toolitem.h>
#include <gtkmm/orientable.h>
#include <gtkmm/adjustment.h>
#include <gtkmm/toolitemgroup.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GtkWrapBox GtkWrapBox;
typedef struct _GtkWrapBoxClass GtkWrapBoxClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{ class WrapBox_Class; } // namespace Gtk
namespace Gtk
{

/** @addtogroup gtkmmEnums gtkmm Enums and Flags */

/**
 * @ingroup gtkmmEnums
 */
enum WrapAllocationMode
{
  WRAP_ALLOCATE_FREE,
  WRAP_ALLOCATE_ALIGNED,
  WRAP_ALLOCATE_HOMOGENEOUS
};

} // namespace Gtk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::WrapAllocationMode> : public Glib::Value_Enum<Gtk::WrapAllocationMode>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{

/**
 * @ingroup gtkmmEnums
 */
enum WrapBoxSpreading
{
  WRAP_BOX_SPREAD_START,
  WRAP_BOX_SPREAD_END,
  WRAP_BOX_SPREAD_EVEN,
  WRAP_BOX_SPREAD_EXPAND
};

} // namespace Gtk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::WrapBoxSpreading> : public Glib::Value_Enum<Gtk::WrapBoxSpreading>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{

/**
 * @ingroup gtkmmEnums
 * @par Bitwise operators:
 * <tt>%WrapBoxPacking operator|(WrapBoxPacking, WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking operator&(WrapBoxPacking, WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking operator^(WrapBoxPacking, WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking operator~(WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking& operator|=(WrapBoxPacking&, WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking& operator&=(WrapBoxPacking&, WrapBoxPacking)</tt><br>
 * <tt>%WrapBoxPacking& operator^=(WrapBoxPacking&, WrapBoxPacking)</tt><br>
 */
enum WrapBoxPacking
{
  WRAP_BOX_H_EXPAND = 1 << 0,
  WRAP_BOX_V_EXPAND = 1 << 1
};

/** @ingroup gtkmmEnums */
inline WrapBoxPacking operator|(WrapBoxPacking lhs, WrapBoxPacking rhs)
  { return static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking operator&(WrapBoxPacking lhs, WrapBoxPacking rhs)
  { return static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking operator^(WrapBoxPacking lhs, WrapBoxPacking rhs)
  { return static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking operator~(WrapBoxPacking flags)
  { return static_cast<WrapBoxPacking>(~static_cast<unsigned>(flags)); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking& operator|=(WrapBoxPacking& lhs, WrapBoxPacking rhs)
  { return (lhs = static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking& operator&=(WrapBoxPacking& lhs, WrapBoxPacking rhs)
  { return (lhs = static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline WrapBoxPacking& operator^=(WrapBoxPacking& lhs, WrapBoxPacking rhs)
  { return (lhs = static_cast<WrapBoxPacking>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Gtk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::WrapBoxPacking> : public Glib::Value_Flags<Gtk::WrapBoxPacking>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{


/** TODO
 *
 * @newin{3,0}
 *
 * @ingroup Widgets
 * @ingroup Containers
 */

class WrapBox
: public Container
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef WrapBox CppObjectType;
  typedef WrapBox_Class CppClassType;
  typedef GtkWrapBox BaseObjectType;
  typedef GtkWrapBoxClass BaseClassType;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  virtual ~WrapBox();

#ifndef DOXYGEN_SHOULD_SKIP_THIS

private:
  friend class WrapBox_Class;
  static CppClassType wrapbox_class_;

  // noncopyable
  WrapBox(const WrapBox&);
  WrapBox& operator=(const WrapBox&);

protected:
  explicit WrapBox(const Glib::ConstructParams& construct_params);
  explicit WrapBox(GtkWrapBox* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GtkObject.
  GtkWrapBox*       gobj()       { return reinterpret_cast<GtkWrapBox*>(gobject_); }

  ///Provides access to the underlying C GtkObject.
  const GtkWrapBox* gobj() const { return reinterpret_cast<GtkWrapBox*>(gobject_); }


public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


private:

  
public:
  explicit WrapBox(WrapAllocationMode mode = WRAP_ALLOCATE_FREE, WrapBoxSpreading horizontal_spreading = WRAP_BOX_SPREAD_START, WrapBoxSpreading vertical_spreading = WRAP_BOX_SPREAD_START, guint horizontal_spacing = 0, guint vertical_spacing = 0);

  
  /** Sets the allocation mode for @a box's children.
   * @param mode The Gtk::WrapAllocationMode to use.
   */
  void set_allocation_mode(WrapAllocationMode mode);
  
  /** Gets the allocation mode.
   * @return The Gtk::WrapAllocationMode for @a box.
   */
  WrapAllocationMode get_allocation_mode() const;

  
  void set_vertical_spreading(WrapBoxSpreading spreading);
  
  WrapBoxSpreading get_vertical_spreading() const;

  
  void set_horizontal_spreading(WrapBoxSpreading spreading);
  
  WrapBoxSpreading get_horizontal_spreading() const;

  
  /** Sets the vertical space to add between children.
   * @param spacing The spacing to use.
   */
  void set_vertical_spacing(guint spacing);
  
  /** Gets the vertical spacing.
   * @return The vertical spacing.
   */
  guint get_vertical_spacing() const;

  
  /** Sets the horizontal space to add between children.
   * @param spacing The spacing to use.
   */
  void set_horizontal_spacing(guint spacing);
  
  /** Gets the horizontal spacing.
   * @return The horizontal spacing.
   */
  guint get_horizontal_spacing() const;

  
  /** Sets the minimum amount of children to line up
   * in @a box's orientation before wrapping.
   * @param n_children The minimum amount of children per line.
   */
  void set_minimum_line_children(guint n_children);
  
  /** Gets the minimum amount of children per line.
   * @return The minimum amount of children per line.
   */
  guint get_minimum_line_children() const;

  
  /** Sets the natural length of items to request and
   * allocate space for in @a box's orientation.
   * 
   * Setting the natural amount of children per line 
   * limits the overall natural size request to be no more 
   * than @a n_children items long in the given orientation.
   * @param n_children The natural amount of children per line.
   */
  void set_natural_line_children(guint n_children);
  
  /** Gets the natural amount of children per line.
   * @return The natural amount of children per line.
   */
  guint get_natural_line_children() const;

  //TODO: Is the default packing appropriate (and like the default for a Box::pack_start())?
  
  /** Adds a child to an Gtk::WrapBox with its packing options set
   * @param widget The child Gtk::Widget to add.
   * @param index The position in the child list to insert, specify -1 to append to the list.
   * @param xpad Horizontal spacing for this child.
   * @param ypad Vertical spacing for this child.
   * @param xexpand Whether this child expands horizontally.
   * @param yexpand Whether this child expands vertically.
   * @param xfill Whether this child fills its horizontal allocation.
   * @param yfill Whether this child fills its vertical allocation.
   */
  void insert_child(Widget& widget, int index, WrapBoxPacking packing = WrapBoxPacking(0));

  //TODO: Documentation
  void append_child(Widget& widget, WrapBoxPacking packing = WrapBoxPacking(0));

  
  /** Reorders the child @a widget in @a box's list of children.
   * @param widget The child to reorder.
   * @param index The new child position.
   */
  void reorder_child(Widget& widget, guint index);


  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The allocation mode to use.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<WrapAllocationMode> property_allocation_mode() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The allocation mode to use.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<WrapAllocationMode> property_allocation_mode() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The spreading mode to use vertically.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<WrapBoxSpreading> property_vertical_spreading() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The spreading mode to use vertically.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<WrapBoxSpreading> property_vertical_spreading() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The spreading mode to use horizontally.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<WrapBoxSpreading> property_horizontal_spreading() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The spreading mode to use horizontally.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<WrapBoxSpreading> property_horizontal_spreading() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The minimum number of children to allocate consecutively in the given orientation.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint> property_minimum_line_children() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The minimum number of children to allocate consecutively in the given orientation.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_minimum_line_children() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The maximum amount of children to request space for consecutively in the given orientation.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint> property_natural_line_children() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The maximum amount of children to request space for consecutively in the given orientation.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_natural_line_children() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of vertical space between two children.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint> property_vertical_spacing() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of vertical space between two children.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_vertical_spacing() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of horizontal space between two children.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint> property_horizontal_spacing() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of horizontal space between two children.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_horizontal_spacing() const;
#endif //#GLIBMM_PROPERTIES_ENABLED


};

} // namespace Gtk


namespace Glib
{
  /** A Glib::wrap() method for this object.
   * 
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gtk::WrapBox
   */
  Gtk::WrapBox* wrap(GtkWrapBox* object, bool take_copy = false);
} //namespace Glib


#endif /* _GTKMM_WRAPBOX_H */

